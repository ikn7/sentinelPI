"""
Feed component for the SentinelPi dashboard.

Displays collected items in a feed format.
"""

from __future__ import annotations

import asyncio
from datetime import datetime
from typing import Any, Sequence

import streamlit as st

from src.storage.models import Item, ItemStatus, Source
from src.utils.dates import format_relative


def _run_async(coro):
    """Run async coroutine from sync context."""
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
    return loop.run_until_complete(coro)


async def _mark_item_read(item_id: str) -> None:
    """Mark an item as read in the database."""
    from src.storage.database import get_session
    from sqlalchemy import update
    from src.utils.dates import now

    async with get_session() as session:
        await session.execute(
            update(Item)
            .where(Item.id == item_id)
            .values(status=ItemStatus.READ, read_at=now())
        )
        await session.commit()


async def _archive_item(item_id: str) -> None:
    """Archive an item in the database."""
    from src.storage.database import get_session
    from sqlalchemy import update

    async with get_session() as session:
        await session.execute(
            update(Item)
            .where(Item.id == item_id)
            .values(status=ItemStatus.ARCHIVED)
        )
        await session.commit()


async def _delete_item(item_id: str) -> None:
    """Delete an item from the database."""
    from src.storage.database import get_session
    from sqlalchemy import delete

    async with get_session() as session:
        await session.execute(delete(Item).where(Item.id == item_id))
        await session.commit()


async def _toggle_star(item_id: str, current_starred: bool) -> None:
    """Toggle starred state for an item."""
    from src.storage.database import get_session
    from sqlalchemy import update

    async with get_session() as session:
        await session.execute(
            update(Item)
            .where(Item.id == item_id)
            .values(starred=not current_starred)
        )
        await session.commit()


def render_item_card(
    item: Item | dict[str, Any],
    source: Source | dict[str, Any] | None = None,
    show_actions: bool = True,
) -> None:
    """
    Render a single item as a card.

    Args:
        item: Item object or dictionary.
        source: Source object or dictionary (optional).
        show_actions: Whether to show action buttons.
    """
    # Handle both Item objects and dicts
    if isinstance(item, dict):
        title = item.get("title", "Sans titre")
        url = item.get("url")
        summary = item.get("summary") or item.get("content", "")[:300]
        author = item.get("author")
        published_at = item.get("published_at")
        image_url = item.get("image_url")
        relevance_score = item.get("relevance_score", 0)
        status = item.get("status", "new")
        starred = item.get("starred", False)
        item_id = item.get("id", "")
    else:
        title = item.title
        url = item.url
        summary = item.summary or (item.content[:300] if item.content else "")
        author = item.author
        published_at = item.published_at
        image_url = item.image_url
        relevance_score = item.relevance_score
        status = item.status.value if isinstance(item.status, ItemStatus) else item.status
        starred = item.starred
        item_id = item.id

    # Source info
    source_name = ""
    if source:
        source_name = source.get("name") if isinstance(source, dict) else source.name

    # Card container
    with st.container():
        # Header row
        col1, col2, col3 = st.columns([0.5, 8, 1.5])

        with col1:
            # Star button
            star_icon = "â­" if starred else "â˜†"
            if st.button(star_icon, key=f"star_{item_id}", help="Favoris"):
                _run_async(_toggle_star(item_id, starred))
                st.rerun()

        with col2:
            # Title with link
            if url:
                st.markdown(f"### [{title}]({url})")
            else:
                st.markdown(f"### {title}")

        with col3:
            # Score badge
            if relevance_score > 0:
                score_color = "green" if relevance_score > 70 else "orange" if relevance_score > 40 else "gray"
                st.markdown(
                    f'<span style="background-color: {score_color}; color: white; '
                    f'padding: 2px 8px; border-radius: 10px; font-size: 12px;">'
                    f'{relevance_score:.0f}</span>',
                    unsafe_allow_html=True,
                )

        # Metadata row
        meta_parts = []
        if source_name:
            meta_parts.append(f"ðŸ“° {source_name}")
        if author:
            meta_parts.append(f"âœï¸ {author}")
        if published_at:
            if isinstance(published_at, str):
                meta_parts.append(f"ðŸ• {published_at}")
            else:
                meta_parts.append(f"ðŸ• {format_relative(published_at)}")

        if meta_parts:
            st.caption(" Â· ".join(meta_parts))

        # Summary
        if summary:
            if len(summary) > 300:
                summary = summary[:300] + "..."
            st.markdown(summary)

        # Image thumbnail
        if image_url:
            try:
                st.image(image_url, width=200)
            except Exception:
                pass  # Skip if image fails to load

        # Actions row
        if show_actions:
            col1, col2, col3, col4, col5 = st.columns([1, 1, 1, 1, 4])

            with col1:
                if st.button("âœ… Lu", key=f"read_{item_id}", help="Marquer comme lu"):
                    _run_async(_mark_item_read(item_id))
                    st.toast("MarquÃ© comme lu")
                    st.rerun()

            with col2:
                if st.button("ðŸ“ Archiver", key=f"archive_{item_id}", help="Archiver"):
                    _run_async(_archive_item(item_id))
                    st.toast("ArchivÃ©")
                    st.rerun()

            with col3:
                if st.button("ðŸ—‘ï¸", key=f"delete_{item_id}", help="Supprimer"):
                    _run_async(_delete_item(item_id))
                    st.toast("SupprimÃ©")
                    st.rerun()

            with col4:
                if url:
                    st.link_button("ðŸ”— Ouvrir", url)

        st.divider()


def render_feed(
    items: Sequence[Item | dict[str, Any]],
    sources: dict[str, Source | dict[str, Any]] | None = None,
    page_size: int = 20,
) -> None:
    """
    Render a feed of items.

    Args:
        items: List of items to display.
        sources: Dictionary mapping source_id to Source.
        page_size: Number of items per page.
    """
    if not items:
        st.info("ðŸ“­ Aucun item Ã  afficher.", icon="â„¹ï¸")
        return

    sources = sources or {}

    # Pagination
    total_items = len(items)
    total_pages = (total_items + page_size - 1) // page_size

    if "feed_page" not in st.session_state:
        st.session_state.feed_page = 0

    # Header with count
    col1, col2 = st.columns([3, 1])
    with col1:
        st.caption(f"ðŸ“‹ {total_items} items")
    with col2:
        if total_pages > 1:
            st.caption(f"Page {st.session_state.feed_page + 1}/{total_pages}")

    # Page items
    start_idx = st.session_state.feed_page * page_size
    end_idx = min(start_idx + page_size, total_items)
    page_items = items[start_idx:end_idx]

    # Render items
    for item in page_items:
        # Get source
        if isinstance(item, dict):
            source_id = item.get("source_id", "")
        else:
            source_id = item.source_id

        source = sources.get(source_id)
        render_item_card(item, source)

    # Pagination controls
    if total_pages > 1:
        col1, col2, col3 = st.columns([1, 2, 1])

        with col1:
            if st.button("â¬…ï¸ PrÃ©cÃ©dent", disabled=st.session_state.feed_page == 0):
                st.session_state.feed_page -= 1
                st.rerun()

        with col2:
            page_select = st.selectbox(
                "Page",
                options=range(total_pages),
                index=st.session_state.feed_page,
                format_func=lambda x: f"Page {x + 1}",
                label_visibility="collapsed",
            )
            if page_select != st.session_state.feed_page:
                st.session_state.feed_page = page_select
                st.rerun()

        with col3:
            if st.button("Suivant âž¡ï¸", disabled=st.session_state.feed_page >= total_pages - 1):
                st.session_state.feed_page += 1
                st.rerun()


def render_compact_feed(
    items: Sequence[Item | dict[str, Any]],
    max_items: int = 10,
) -> None:
    """
    Render a compact feed (for widgets/sidebars).

    Args:
        items: List of items to display.
        max_items: Maximum number of items to show.
    """
    if not items:
        st.caption("Aucun item rÃ©cent")
        return

    for item in items[:max_items]:
        if isinstance(item, dict):
            title = item.get("title", "Sans titre")
            url = item.get("url")
            published_at = item.get("published_at")
        else:
            title = item.title
            url = item.url
            published_at = item.published_at

        # Truncate title
        if len(title) > 60:
            title = title[:57] + "..."

        col1, col2 = st.columns([4, 1])

        with col1:
            if url:
                st.markdown(f"[{title}]({url})")
            else:
                st.text(title)

        with col2:
            if published_at:
                if isinstance(published_at, datetime):
                    st.caption(format_relative(published_at))
                else:
                    st.caption(published_at)
