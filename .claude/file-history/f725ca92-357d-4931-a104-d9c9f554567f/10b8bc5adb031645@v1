"""
SentinelPi Dashboard - Main Streamlit application.

Provides a web interface for monitoring and managing the watch station.
"""

from __future__ import annotations

import asyncio
from datetime import datetime, timedelta

import streamlit as st

from src.utils.config import get_settings
from src.utils.logging import create_logger, setup_logging

log = create_logger("dashboard.app")


def run_async(coro):
    """Run an async coroutine from sync context."""
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
    return loop.run_until_complete(coro)


async def add_source_to_db(source):
    """Add a source to the database."""
    from src.storage.database import get_session
    async with get_session() as session:
        session.add(source)
        await session.commit()


async def sync_sources_from_yaml():
    """Sync sources from YAML config to database."""
    import hashlib
    from src.storage.database import get_session, init_database
    from src.storage.models import Source, SourceType
    from src.utils.config import load_sources_config
    from sqlalchemy import select

    # Ensure database is initialized
    await init_database()

    sources_config = load_sources_config()
    sources_list = sources_config.get("sources", [])

    async with get_session() as session:
        for config in sources_list:
            # Generate deterministic ID from name + URL
            source_key = f"{config.get('name', '')}:{config.get('url', '')}"
            source_id = hashlib.sha256(source_key.encode()).hexdigest()[:32]

            # Check if exists
            result = await session.execute(
                select(Source).where(Source.id == source_id)
            )
            existing = result.scalar_one_or_none()

            if existing:
                # Update
                existing.name = config.get("name", existing.name)
                existing.url = config.get("url", existing.url)
                existing.enabled = config.get("enabled", True)
                existing.interval_minutes = config.get("interval_minutes", 60)
                existing.priority = config.get("priority", 2)
                existing.category = config.get("category")
                existing.tags = config.get("tags", [])
                existing.config = config.get("config", {})
            else:
                # Create
                source = Source()
                source.id = source_id
                source.name = config.get("name", "Unnamed")
                source.type = SourceType(config.get("type", "rss"))
                source.url = config.get("url", "")
                source.enabled = config.get("enabled", True)
                source.interval_minutes = config.get("interval_minutes", 60)
                source.priority = config.get("priority", 2)
                source.category = config.get("category")
                source.tags = config.get("tags", [])
                source.config = config.get("config", {})
                session.add(source)

        await session.commit()

    return len(sources_list)


async def sync_filters_from_yaml():
    """Sync filters from YAML config to database."""
    import hashlib
    from src.storage.database import get_session, init_database
    from src.storage.models import Filter, FilterAction
    from src.utils.config import load_filters_config
    from sqlalchemy import select

    # Ensure database is initialized
    await init_database()

    filters_config = load_filters_config()
    filters_list = filters_config.get("filters", [])

    async with get_session() as session:
        for config in filters_list:
            # Generate deterministic ID from name
            filter_name = config.get("name", "")
            filter_id = hashlib.sha256(filter_name.encode()).hexdigest()[:32]

            # Check if exists
            result = await session.execute(
                select(Filter).where(Filter.id == filter_id)
            )
            existing = result.scalar_one_or_none()

            if existing:
                # Update
                existing.name = config.get("name", existing.name)
                existing.description = config.get("description")
                existing.action = FilterAction(config.get("action", "include"))
                existing.action_params = config.get("action_params", {})
                existing.conditions = config.get("conditions", {})
                existing.score_modifier = config.get("score_modifier", 0)
                existing.priority = config.get("priority", 100)
                existing.enabled = config.get("enabled", True)
            else:
                # Create
                filter_obj = Filter()
                filter_obj.id = filter_id
                filter_obj.name = config.get("name", "Unnamed")
                filter_obj.description = config.get("description")
                filter_obj.action = FilterAction(config.get("action", "include"))
                filter_obj.action_params = config.get("action_params", {})
                filter_obj.conditions = config.get("conditions", {})
                filter_obj.score_modifier = config.get("score_modifier", 0)
                filter_obj.priority = config.get("priority", 100)
                filter_obj.enabled = config.get("enabled", True)
                session.add(filter_obj)

        await session.commit()

    return len(filters_list)


async def get_all_sources():
    """Get all sources from the database."""
    from src.storage.database import get_session
    from src.storage.models import Source
    from sqlalchemy import select

    async with get_session() as session:
        result = await session.execute(select(Source).order_by(Source.name))
        return result.scalars().all()


async def get_all_filters():
    """Get all filters from the database."""
    from src.storage.database import get_session
    from src.storage.models import Filter
    from sqlalchemy import select

    async with get_session() as session:
        result = await session.execute(select(Filter).order_by(Filter.priority))
        return result.scalars().all()


async def get_all_alerts(severity_filter=None, date_filter=None, limit=50):
    """Get alerts from the database."""
    from src.storage.database import get_session
    from src.storage.models import Alert, AlertSeverity
    from sqlalchemy import select, and_
    from datetime import datetime, timedelta, timezone

    async with get_session() as session:
        query = select(Alert).order_by(Alert.created_at.desc()).limit(limit)

        conditions = []

        if severity_filter and severity_filter != "all":
            conditions.append(Alert.severity == AlertSeverity(severity_filter))

        if date_filter:
            now = datetime.now(timezone.utc)
            if date_filter == "today":
                cutoff = now - timedelta(days=1)
            elif date_filter == "week":
                cutoff = now - timedelta(days=7)
            elif date_filter == "month":
                cutoff = now - timedelta(days=30)
            else:
                cutoff = None

            if cutoff:
                conditions.append(Alert.created_at >= cutoff)

        if conditions:
            query = query.where(and_(*conditions))

        result = await session.execute(query)
        return result.scalars().all()


async def get_stats(period="week"):
    """Get statistics for the dashboard."""
    from src.storage.database import get_session
    from src.storage.models import Item, Alert, Source
    from sqlalchemy import select, func
    from datetime import datetime, timedelta, timezone

    now = datetime.now(timezone.utc)
    if period == "week":
        cutoff = now - timedelta(days=7)
    elif period == "month":
        cutoff = now - timedelta(days=30)
    elif period == "quarter":
        cutoff = now - timedelta(days=90)
    else:
        cutoff = now - timedelta(days=365)

    async with get_session() as session:
        # Items count
        result = await session.execute(
            select(func.count(Item.id)).where(Item.collected_at >= cutoff)
        )
        items_count = result.scalar() or 0

        # Alerts count
        result = await session.execute(
            select(func.count(Alert.id)).where(Alert.created_at >= cutoff)
        )
        alerts_count = result.scalar() or 0

        # Active sources
        result = await session.execute(
            select(func.count(Source.id)).where(Source.enabled == True)
        )
        sources_count = result.scalar() or 0

        # Top items
        result = await session.execute(
            select(Item)
            .where(Item.collected_at >= cutoff)
            .order_by(Item.relevance_score.desc())
            .limit(10)
        )
        top_items = result.scalars().all()

        # Items by source
        result = await session.execute(
            select(Source.name, func.count(Item.id).label("count"))
            .join(Item, Item.source_id == Source.id)
            .where(Item.collected_at >= cutoff)
            .group_by(Source.id)
            .order_by(func.count(Item.id).desc())
            .limit(10)
        )
        items_by_source = result.all()

        return {
            "items_count": items_count,
            "alerts_count": alerts_count,
            "sources_count": sources_count,
            "top_items": top_items,
            "items_by_source": items_by_source,
        }


async def get_feed_items(search=None, category=None, date_filter=None, limit=50):
    """Get items for the feed page."""
    from src.storage.database import get_session
    from src.storage.models import Item, Source
    from sqlalchemy import select, and_
    from datetime import datetime, timedelta, timezone

    async with get_session() as session:
        # Build query
        query = select(Item).order_by(Item.collected_at.desc()).limit(limit)

        conditions = []

        # Date filter
        if date_filter:
            now = datetime.now(timezone.utc)
            if date_filter == "today":
                cutoff = now - timedelta(days=1)
            elif date_filter == "week":
                cutoff = now - timedelta(days=7)
            elif date_filter == "month":
                cutoff = now - timedelta(days=30)
            else:
                cutoff = None

            if cutoff:
                conditions.append(Item.collected_at >= cutoff)

        # Search filter
        if search:
            search_pattern = f"%{search}%"
            conditions.append(
                (Item.title.ilike(search_pattern)) |
                (Item.content.ilike(search_pattern))
            )

        if conditions:
            query = query.where(and_(*conditions))

        result = await session.execute(query)
        items = result.scalars().all()

        # Get sources dict
        source_ids = set(item.source_id for item in items)
        sources_dict = {}
        if source_ids:
            result = await session.execute(
                select(Source).where(Source.id.in_(source_ids))
            )
            for source in result.scalars().all():
                sources_dict[source.id] = source

        return items, sources_dict

# Page configuration
st.set_page_config(
    page_title="SentinelPi",
    page_icon="ðŸ›¡ï¸",
    layout="wide",
    initial_sidebar_state="expanded",
)


def init_session_state() -> None:
    """Initialize session state variables."""
    if "initialized" not in st.session_state:
        st.session_state.initialized = True
        st.session_state.current_page = "feed"
        st.session_state.selected_source = None
        st.session_state.selected_category = "all"
        st.session_state.search_query = ""
        st.session_state.date_filter = "all"
        st.session_state.status_filter = "all"

        # Sync sources and filters from YAML to database on first load
        try:
            sources_count = run_async(sync_sources_from_yaml())
            log.info(f"Synced {sources_count} sources from YAML to database")
        except Exception as e:
            log.error(f"Failed to sync sources: {e}")

        try:
            filters_count = run_async(sync_filters_from_yaml())
            log.info(f"Synced {filters_count} filters from YAML to database")
        except Exception as e:
            log.error(f"Failed to sync filters: {e}")


def render_sidebar() -> str:
    """Render the sidebar navigation."""
    with st.sidebar:
        st.title("ðŸ›¡ï¸ SentinelPi")
        st.caption("Station de veille automatisÃ©e")

        st.divider()

        # Navigation
        page = st.radio(
            "Navigation",
            options=["feed", "sources", "filters", "alerts", "stats", "settings"],
            format_func=lambda x: {
                "feed": "ðŸ“° Flux",
                "sources": "ðŸ“¡ Sources",
                "filters": "ðŸŽ¯ Filtres",
                "alerts": "ðŸ”” Alertes",
                "stats": "ðŸ“Š Statistiques",
                "settings": "âš™ï¸ ParamÃ¨tres",
            }.get(x, x),
            label_visibility="collapsed",
        )

        st.divider()

        # Quick stats
        st.subheader("ðŸ“ˆ AperÃ§u")

        col1, col2 = st.columns(2)
        with col1:
            st.metric("Sources", "--", help="Sources actives")
        with col2:
            st.metric("Items (24h)", "--", help="Nouveaux items")

        col3, col4 = st.columns(2)
        with col3:
            st.metric("Alertes", "--", help="Alertes aujourd'hui")
        with col4:
            st.metric("En attente", "--", help="Items non lus")

        st.divider()

        # System status
        st.subheader("ðŸ–¥ï¸ SystÃ¨me")
        st.success("â— En ligne", icon="âœ…")

        settings = get_settings()
        st.caption(f"v{settings.app.version}")

        return page


def render_feed_page() -> None:
    """Render the main feed page."""
    st.header("ðŸ“° Flux d'actualitÃ©s")

    # Filters row
    col1, col2, col3, col4 = st.columns([2, 2, 2, 1])

    with col1:
        search = st.text_input(
            "ðŸ” Rechercher",
            placeholder="Mots-clÃ©s...",
            label_visibility="collapsed",
        )

    with col2:
        category = st.selectbox(
            "CatÃ©gorie",
            options=["all", "presse", "tech", "social", "concurrents"],
            format_func=lambda x: "Toutes catÃ©gories" if x == "all" else x.capitalize(),
            label_visibility="collapsed",
        )

    with col3:
        date_filter = st.selectbox(
            "PÃ©riode",
            options=["all", "today", "week", "month"],
            format_func=lambda x: {
                "all": "Toutes dates",
                "today": "Aujourd'hui",
                "week": "Cette semaine",
                "month": "Ce mois",
            }.get(x, x),
            label_visibility="collapsed",
        )

    with col4:
        if st.button("ðŸ”„ Actualiser", use_container_width=True):
            st.rerun()

    st.divider()

    # Load items from database
    items, sources_dict = run_async(get_feed_items(
        search=search if search else None,
        category=category if category != "all" else None,
        date_filter=date_filter if date_filter != "all" else None,
    ))

    if items:
        st.caption(f"{len(items)} items")
        from src.dashboard.components.feed import render_feed
        render_feed(items, sources_dict)
    else:
        st.info("ðŸ“­ Aucun item Ã  afficher.", icon="â„¹ï¸")
        with st.expander("ðŸ’¡ Comment dÃ©marrer", expanded=True):
            st.markdown("""
            1. **Ajoutez des sources** dans l'onglet ðŸ“¡ Sources
            2. **Configurez des filtres** dans l'onglet ðŸŽ¯ Filtres
            3. **Lancez la collecte** avec la commande `sentinelpi`
            4. Les nouveaux articles apparaÃ®tront ici automatiquement
            """)


def render_sources_page() -> None:
    """Render the sources management page."""
    st.header("ðŸ“¡ Gestion des sources")

    # Load sources from database
    sources = run_async(get_all_sources())

    # Action buttons
    col1, col2, col3 = st.columns([1, 1, 4])
    with col1:
        if st.button("âž• Ajouter", use_container_width=True):
            st.session_state.show_add_source = True
    with col2:
        if st.button("ðŸ”„ RafraÃ®chir", use_container_width=True):
            st.rerun()

    st.divider()

    # Filter sources by type
    rss_sources = [s for s in sources if s.type.value == "rss"]
    web_sources = [s for s in sources if s.type.value == "web"]
    social_sources = [s for s in sources if s.type.value in ("reddit", "mastodon")]
    video_sources = [s for s in sources if s.type.value == "youtube"]

    # Source type tabs
    tabs = st.tabs([f"ðŸ“° RSS ({len(rss_sources)})", f"ðŸŒ Web ({len(web_sources)})",
                    f"ðŸ’¬ Social ({len(social_sources)})", f"ðŸ“º VidÃ©o ({len(video_sources)})"])

    with tabs[0]:  # RSS
        st.subheader("Flux RSS/Atom")
        if rss_sources:
            from src.dashboard.components.sources import render_source_card
            for source in rss_sources:
                render_source_card(source, expanded=True, show_actions=True)
        else:
            st.info("Aucun flux RSS configurÃ©.")

    with tabs[1]:  # Web
        st.subheader("Pages Web (scraping)")
        if web_sources:
            from src.dashboard.components.sources import render_source_card
            for source in web_sources:
                render_source_card(source, expanded=True, show_actions=True)
        else:
            st.info("Aucune source web configurÃ©e.")

    with tabs[2]:  # Social
        st.subheader("RÃ©seaux sociaux")
        if social_sources:
            from src.dashboard.components.sources import render_source_card
            for source in social_sources:
                render_source_card(source, expanded=True, show_actions=True)
        else:
            st.info("Aucune source sociale configurÃ©e.")

    with tabs[3]:  # Video
        st.subheader("ChaÃ®nes vidÃ©o")
        if video_sources:
            from src.dashboard.components.sources import render_source_card
            for source in video_sources:
                render_source_card(source, expanded=True, show_actions=True)
        else:
            st.info("Aucune chaÃ®ne configurÃ©e.")

    # Add source form
    if st.session_state.get("show_add_source"):
        with st.form("add_source_form"):
            st.subheader("Ajouter une source")

            source_type = st.selectbox(
                "Type",
                options=["rss", "web", "reddit", "mastodon", "youtube"],
            )

            name = st.text_input("Nom", placeholder="Ma nouvelle source")
            url = st.text_input("URL", placeholder="https://...")
            category = st.text_input("CatÃ©gorie", placeholder="tech, presse, etc.")
            interval = st.number_input("Intervalle (minutes)", min_value=5, value=60)

            col1, col2 = st.columns(2)
            with col1:
                if st.form_submit_button("ðŸ’¾ Enregistrer", use_container_width=True):
                    if name and url:
                        try:
                            import hashlib
                            from src.storage.models import Source, SourceType

                            # Generate ID
                            source_key = f"{name}:{url}"
                            source_id = hashlib.sha256(source_key.encode()).hexdigest()[:32]

                            # Create source
                            new_source = Source()
                            new_source.id = source_id
                            new_source.name = name
                            new_source.type = SourceType(source_type)
                            new_source.url = url
                            new_source.category = category if category else None
                            new_source.interval_minutes = interval
                            new_source.enabled = True
                            new_source.priority = 2
                            new_source.config = {}

                            run_async(add_source_to_db(new_source))
                            st.success(f"Source '{name}' ajoutÃ©e !")
                            st.session_state.show_add_source = False
                            st.rerun()
                        except Exception as e:
                            st.error(f"Erreur: {e}")
                    else:
                        st.warning("Nom et URL requis")
            with col2:
                if st.form_submit_button("âŒ Annuler", use_container_width=True):
                    st.session_state.show_add_source = False


def render_filters_page() -> None:
    """Render the filters configuration page."""
    st.header("ðŸŽ¯ Configuration des filtres")

    # Load filters from database
    filters = run_async(get_all_filters())

    col1, col2 = st.columns([1, 5])
    with col1:
        if st.button("âž• Nouveau filtre", use_container_width=True):
            st.session_state.show_add_filter = True
    with col2:
        st.caption(f"{len(filters)} filtres configurÃ©s")

    st.divider()

    # Filter by action type
    alert_filters = [f for f in filters if f.action.value == "alert"]
    highlight_filters = [f for f in filters if f.action.value == "highlight"]
    tag_filters = [f for f in filters if f.action.value == "tag"]
    exclude_filters = [f for f in filters if f.action.value == "exclude"]

    tabs = st.tabs([
        f"ðŸ”” Alertes ({len(alert_filters)})",
        f"â­ Mise en avant ({len(highlight_filters)})",
        f"ðŸ·ï¸ Tags ({len(tag_filters)})",
        f"ðŸš« Exclusions ({len(exclude_filters)})"
    ])

    with tabs[0]:  # Alerts
        st.subheader("Filtres d'alerte")
        if alert_filters:
            from src.dashboard.components.filters import render_filter_card
            for f in alert_filters:
                render_filter_card(f, expanded=True, show_actions=True)
        else:
            st.info("Aucun filtre d'alerte configurÃ©.")

    with tabs[1]:  # Highlight
        st.subheader("Filtres de mise en avant")
        if highlight_filters:
            from src.dashboard.components.filters import render_filter_card
            for f in highlight_filters:
                render_filter_card(f, expanded=True, show_actions=True)
        else:
            st.info("Aucun filtre de mise en avant configurÃ©.")

    with tabs[2]:  # Tags
        st.subheader("Filtres de tagging")
        if tag_filters:
            from src.dashboard.components.filters import render_filter_card
            for f in tag_filters:
                render_filter_card(f, expanded=True, show_actions=True)
        else:
            st.info("Aucun filtre de tagging configurÃ©.")

    with tabs[3]:  # Exclusions
        st.subheader("Filtres d'exclusion")
        if exclude_filters:
            from src.dashboard.components.filters import render_filter_card
            for f in exclude_filters:
                render_filter_card(f, expanded=True, show_actions=True)
        else:
            st.info("Aucun filtre d'exclusion configurÃ©.")


def render_alerts_page() -> None:
    """Render the alerts history page."""
    st.header("ðŸ”” Historique des alertes")

    # Filters
    col1, col2, col3 = st.columns([2, 2, 2])

    with col1:
        severity = st.selectbox(
            "SÃ©vÃ©ritÃ©",
            options=["all", "critical", "warning", "notice", "info"],
            format_func=lambda x: {
                "all": "Toutes",
                "critical": "ðŸš¨ Critique",
                "warning": "âš ï¸ Attention",
                "notice": "ðŸ“¢ Notice",
                "info": "â„¹ï¸ Info",
            }.get(x, x),
        )

    with col2:
        date_range = st.selectbox(
            "PÃ©riode",
            options=["today", "week", "month", "all"],
            format_func=lambda x: {
                "today": "Aujourd'hui",
                "week": "Cette semaine",
                "month": "Ce mois",
                "all": "Tout",
            }.get(x, x),
        )

    with col3:
        if st.button("ðŸ”„ Actualiser", use_container_width=True):
            st.rerun()

    st.divider()

    # Load alerts
    alerts = run_async(get_all_alerts(
        severity_filter=severity if severity != "all" else None,
        date_filter=date_range if date_range != "all" else None,
    ))

    if alerts:
        st.caption(f"{len(alerts)} alertes")
        from src.dashboard.components.alerts import render_alert_card
        for alert in alerts:
            render_alert_card(alert, show_actions=True)
    else:
        st.info("ðŸ“­ Aucune alerte enregistrÃ©e.", icon="â„¹ï¸")


def render_stats_page() -> None:
    """Render the statistics page."""
    st.header("ðŸ“Š Statistiques")

    # Time period selector
    period = st.selectbox(
        "PÃ©riode",
        options=["week", "month", "quarter", "year"],
        format_func=lambda x: {
            "week": "7 derniers jours",
            "month": "30 derniers jours",
            "quarter": "3 derniers mois",
            "year": "12 derniers mois",
        }.get(x, x),
    )

    st.divider()

    # Load stats
    stats = run_async(get_stats(period))

    # Metrics row
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric(
            "Items collectÃ©s",
            stats["items_count"],
            help="Total des items collectÃ©s sur la pÃ©riode",
        )

    with col2:
        st.metric(
            "Alertes dÃ©clenchÃ©es",
            stats["alerts_count"],
            help="Alertes envoyÃ©es sur la pÃ©riode",
        )

    with col3:
        st.metric(
            "Sources actives",
            stats["sources_count"],
            help="Sources activÃ©es",
        )

    with col4:
        avg_score = 0
        if stats["top_items"]:
            avg_score = sum(i.relevance_score for i in stats["top_items"]) / len(stats["top_items"])
        st.metric(
            "Score moyen",
            f"{avg_score:.0f}",
            help="Score moyen des top items",
        )

    st.divider()

    # Charts
    col1, col2 = st.columns(2)

    with col1:
        st.subheader("ðŸ“Š RÃ©partition par source")
        if stats["items_by_source"]:
            import pandas as pd
            df = pd.DataFrame(stats["items_by_source"], columns=["Source", "Items"])
            st.bar_chart(df.set_index("Source"))
        else:
            st.info("Pas assez de donnÃ©es.")

    with col2:
        st.subheader("ðŸ† Top 10 items (par score)")
        if stats["top_items"]:
            for i, item in enumerate(stats["top_items"][:10], 1):
                score_color = "ðŸŸ¢" if item.relevance_score > 70 else "ðŸŸ¡" if item.relevance_score > 40 else "âšª"
                title = item.title[:50] + "..." if len(item.title) > 50 else item.title
                st.markdown(f"{i}. {score_color} **{item.relevance_score:.0f}** - {title}")
        else:
            st.info("Aucun item Ã  afficher.")


def render_settings_page() -> None:
    """Render the settings page."""
    st.header("âš™ï¸ ParamÃ¨tres")

    settings = get_settings()

    tabs = st.tabs(["ðŸ”§ GÃ©nÃ©ral", "ðŸ“¡ Collecte", "ðŸ”” Alertes", "ðŸ—„ï¸ Base de donnÃ©es"])

    with tabs[0]:  # General
        st.subheader("Configuration gÃ©nÃ©rale")

        col1, col2 = st.columns(2)
        with col1:
            st.text_input("Nom de l'application", value=settings.app.name, disabled=True)
            st.text_input("Version", value=settings.app.version, disabled=True)

        with col2:
            st.text_input("Fuseau horaire", value=settings.app.timezone, disabled=True)
            st.text_input("Niveau de log", value=settings.logging.level, disabled=True)

        st.caption("ðŸ’¡ Modifiez ces paramÃ¨tres dans `config/settings.yaml`")

    with tabs[1]:  # Collection
        st.subheader("ParamÃ¨tres de collecte")

        col1, col2 = st.columns(2)
        with col1:
            st.number_input(
                "Intervalle par dÃ©faut (min)",
                value=settings.collection.default_interval_minutes,
                disabled=True,
            )
            st.number_input(
                "Collecteurs simultanÃ©s",
                value=settings.collection.max_concurrent_collectors,
                disabled=True,
            )

        with col2:
            st.number_input(
                "Items max par source",
                value=settings.collection.max_items_per_source,
                disabled=True,
            )
            st.number_input(
                "FenÃªtre dÃ©dup (jours)",
                value=settings.collection.dedup_window_days,
                disabled=True,
            )

    with tabs[2]:  # Alerts
        st.subheader("Configuration des alertes")

        st.markdown("**Canaux configurÃ©s:**")

        telegram_status = "âœ… ConfigurÃ©" if settings.telegram_bot_token else "âŒ Non configurÃ©"
        email_status = "âœ… ConfigurÃ©" if settings.email_user else "âŒ Non configurÃ©"
        webhook_status = "âœ… ConfigurÃ©" if settings.webhook_url else "âŒ Non configurÃ©"

        col1, col2, col3 = st.columns(3)
        with col1:
            st.info(f"ðŸ“± Telegram: {telegram_status}")
        with col2:
            st.info(f"ðŸ“§ Email: {email_status}")
        with col3:
            st.info(f"ðŸ”— Webhook: {webhook_status}")

        st.caption("ðŸ’¡ Configurez les tokens dans le fichier `.env`")

    with tabs[3]:  # Database
        st.subheader("Base de donnÃ©es")

        st.text_input("Chemin", value=settings.database.path, disabled=True)

        col1, col2 = st.columns(2)
        with col1:
            if st.button("ðŸ“Š Statistiques DB"):
                st.info("FonctionnalitÃ© Ã  venir")
        with col2:
            if st.button("ðŸ—‘ï¸ Nettoyer"):
                st.warning("Cette action supprimera les anciens items.")


def main() -> None:
    """Main entry point for the dashboard."""
    # Initialize
    setup_logging()
    init_session_state()

    # Custom CSS
    st.markdown("""
    <style>
    .stMetric {
        background-color: #f0f2f6;
        padding: 10px;
        border-radius: 5px;
    }
    .stDataFrame {
        font-size: 14px;
    }
    </style>
    """, unsafe_allow_html=True)

    # Render sidebar and get selected page
    page = render_sidebar()

    # Render selected page
    if page == "feed":
        render_feed_page()
    elif page == "sources":
        render_sources_page()
    elif page == "filters":
        render_filters_page()
    elif page == "alerts":
        render_alerts_page()
    elif page == "stats":
        render_stats_page()
    elif page == "settings":
        render_settings_page()


if __name__ == "__main__":
    main()
