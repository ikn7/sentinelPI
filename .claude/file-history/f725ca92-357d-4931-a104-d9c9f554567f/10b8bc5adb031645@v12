"""
SentinelPi Dashboard - Main Streamlit application.

Provides a web interface for monitoring and managing the watch station.
"""

from __future__ import annotations

import asyncio
from datetime import datetime, timedelta

import streamlit as st

from src.utils.config import get_settings
from src.utils.logging import create_logger, setup_logging

log = create_logger("dashboard.app")


def run_async(coro):
    """Run an async coroutine from sync context."""
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
    return loop.run_until_complete(coro)


async def add_source_to_db(source):
    """Add a source to the database."""
    from src.storage.database import get_session
    async with get_session() as session:
        session.add(source)
        await session.commit()


async def sync_sources_from_yaml():
    """Sync sources from YAML config to database."""
    import hashlib
    from src.storage.database import get_session, init_database
    from src.storage.models import Source, SourceType
    from src.utils.config import load_sources_config
    from sqlalchemy import select

    # Ensure database is initialized
    await init_database()

    sources_config = load_sources_config()
    sources_list = sources_config.get("sources", [])

    async with get_session() as session:
        for config in sources_list:
            # Generate deterministic ID from name + URL
            source_key = f"{config.get('name', '')}:{config.get('url', '')}"
            source_id = hashlib.sha256(source_key.encode()).hexdigest()[:32]

            # Check if exists
            result = await session.execute(
                select(Source).where(Source.id == source_id)
            )
            existing = result.scalar_one_or_none()

            if existing:
                # Update
                existing.name = config.get("name", existing.name)
                existing.url = config.get("url", existing.url)
                existing.enabled = config.get("enabled", True)
                existing.interval_minutes = config.get("interval_minutes", 60)
                existing.priority = config.get("priority", 2)
                existing.category = config.get("category")
                existing.tags = config.get("tags", [])
                existing.config = config.get("config", {})
            else:
                # Create
                source = Source()
                source.id = source_id
                source.name = config.get("name", "Unnamed")
                source.type = SourceType(config.get("type", "rss"))
                source.url = config.get("url", "")
                source.enabled = config.get("enabled", True)
                source.interval_minutes = config.get("interval_minutes", 60)
                source.priority = config.get("priority", 2)
                source.category = config.get("category")
                source.tags = config.get("tags", [])
                source.config = config.get("config", {})
                session.add(source)

        await session.commit()

    return len(sources_list)


async def sync_filters_from_yaml():
    """Sync filters from YAML config to database."""
    import hashlib
    from src.storage.database import get_session, init_database
    from src.storage.models import Filter, FilterAction
    from src.utils.config import load_filters_config
    from sqlalchemy import select

    # Ensure database is initialized
    await init_database()

    filters_config = load_filters_config()
    filters_list = filters_config.get("filters", [])

    async with get_session() as session:
        for config in filters_list:
            # Generate deterministic ID from name
            filter_name = config.get("name", "")
            filter_id = hashlib.sha256(filter_name.encode()).hexdigest()[:32]

            # Check if exists
            result = await session.execute(
                select(Filter).where(Filter.id == filter_id)
            )
            existing = result.scalar_one_or_none()

            if existing:
                # Update
                existing.name = config.get("name", existing.name)
                existing.description = config.get("description")
                existing.action = FilterAction(config.get("action", "include"))
                existing.action_params = config.get("action_params", {})
                existing.conditions = config.get("conditions", {})
                existing.score_modifier = config.get("score_modifier", 0)
                existing.priority = config.get("priority", 100)
                existing.enabled = config.get("enabled", True)
            else:
                # Create
                filter_obj = Filter()
                filter_obj.id = filter_id
                filter_obj.name = config.get("name", "Unnamed")
                filter_obj.description = config.get("description")
                filter_obj.action = FilterAction(config.get("action", "include"))
                filter_obj.action_params = config.get("action_params", {})
                filter_obj.conditions = config.get("conditions", {})
                filter_obj.score_modifier = config.get("score_modifier", 0)
                filter_obj.priority = config.get("priority", 100)
                filter_obj.enabled = config.get("enabled", True)
                session.add(filter_obj)

        await session.commit()

    return len(filters_list)


async def _get_sidebar_stats():
    """Get quick stats for the sidebar."""
    from src.storage.database import get_session, init_database
    from src.storage.models import Source, Item, Alert, ItemStatus
    from sqlalchemy import select, func
    from datetime import datetime, timedelta, timezone

    await init_database()

    now = datetime.now(timezone.utc)
    cutoff_24h = now - timedelta(hours=24)

    async with get_session() as session:
        # Active sources
        result = await session.execute(
            select(func.count(Source.id)).where(Source.enabled == True)
        )
        sources = result.scalar() or 0

        # Items last 24h
        result = await session.execute(
            select(func.count(Item.id)).where(Item.collected_at >= cutoff_24h)
        )
        items_24h = result.scalar() or 0

        # Alerts last 24h
        result = await session.execute(
            select(func.count(Alert.id)).where(Alert.created_at >= cutoff_24h)
        )
        alerts = result.scalar() or 0

        # Unread items
        result = await session.execute(
            select(func.count(Item.id)).where(Item.status == ItemStatus.NEW)
        )
        unread = result.scalar() or 0

    return {
        "sources": sources,
        "items_24h": items_24h,
        "alerts": alerts,
        "unread": unread,
    }


async def _update_filter_db(filter_id, name, desc, action, action_params, conditions, score_mod, priority, enabled):
    """Update a filter in the database."""
    from src.storage.database import get_session
    from src.storage.models import Filter, FilterAction
    from sqlalchemy import select
    import json

    async with get_session() as session:
        result = await session.execute(select(Filter).where(Filter.id == filter_id))
        f = result.scalar_one_or_none()
        if f:
            f.name = name
            f.description = desc
            f.action = FilterAction(action)
            f.action_params = action_params
            f.conditions = conditions
            f.score_modifier = score_mod
            f.priority = priority
            f.enabled = enabled
            await session.commit()


async def get_all_sources():
    """Get all sources from the database."""
    from src.storage.database import get_session
    from src.storage.models import Source
    from sqlalchemy import select

    async with get_session() as session:
        result = await session.execute(select(Source).order_by(Source.name))
        return result.scalars().all()


async def get_all_filters():
    """Get all filters from the database."""
    from src.storage.database import get_session
    from src.storage.models import Filter
    from sqlalchemy import select

    async with get_session() as session:
        result = await session.execute(select(Filter).order_by(Filter.priority))
        return result.scalars().all()


async def get_all_alerts(severity_filter=None, date_filter=None, limit=50):
    """Get alerts from the database."""
    from src.storage.database import get_session
    from src.storage.models import Alert, AlertSeverity
    from sqlalchemy import select, and_
    from datetime import datetime, timedelta, timezone

    async with get_session() as session:
        query = select(Alert).order_by(Alert.created_at.desc()).limit(limit)

        conditions = []

        if severity_filter and severity_filter != "all":
            conditions.append(Alert.severity == AlertSeverity(severity_filter))

        if date_filter:
            now = datetime.now(timezone.utc)
            if date_filter == "today":
                cutoff = now - timedelta(days=1)
            elif date_filter == "week":
                cutoff = now - timedelta(days=7)
            elif date_filter == "month":
                cutoff = now - timedelta(days=30)
            else:
                cutoff = None

            if cutoff:
                conditions.append(Alert.created_at >= cutoff)

        if conditions:
            query = query.where(and_(*conditions))

        result = await session.execute(query)
        return result.scalars().all()


async def get_stats(period="week"):
    """Get statistics for the dashboard."""
    from src.storage.database import get_session
    from src.storage.models import Item, Alert, Source
    from sqlalchemy import select, func
    from datetime import datetime, timedelta, timezone

    now = datetime.now(timezone.utc)
    if period == "week":
        cutoff = now - timedelta(days=7)
    elif period == "month":
        cutoff = now - timedelta(days=30)
    elif period == "quarter":
        cutoff = now - timedelta(days=90)
    else:
        cutoff = now - timedelta(days=365)

    async with get_session() as session:
        # Items count
        result = await session.execute(
            select(func.count(Item.id)).where(Item.collected_at >= cutoff)
        )
        items_count = result.scalar() or 0

        # Alerts count
        result = await session.execute(
            select(func.count(Alert.id)).where(Alert.created_at >= cutoff)
        )
        alerts_count = result.scalar() or 0

        # Active sources
        result = await session.execute(
            select(func.count(Source.id)).where(Source.enabled == True)
        )
        sources_count = result.scalar() or 0

        # Top items
        result = await session.execute(
            select(Item)
            .where(Item.collected_at >= cutoff)
            .order_by(Item.relevance_score.desc())
            .limit(10)
        )
        top_items = result.scalars().all()

        # Items by source
        result = await session.execute(
            select(Source.name, func.count(Item.id).label("count"))
            .join(Item, Item.source_id == Source.id)
            .where(Item.collected_at >= cutoff)
            .group_by(Source.id)
            .order_by(func.count(Item.id).desc())
            .limit(10)
        )
        items_by_source = result.all()

        return {
            "items_count": items_count,
            "alerts_count": alerts_count,
            "sources_count": sources_count,
            "top_items": top_items,
            "items_by_source": items_by_source,
        }


async def get_feed_items(search=None, category=None, date_from=None, date_to=None, status_filter=None, limit=100):
    """Get items for the feed page."""
    from src.storage.database import get_session
    from src.storage.models import Item, Source, ItemStatus
    from sqlalchemy import select, and_
    from datetime import datetime, timedelta, timezone

    async with get_session() as session:
        # Build query
        query = select(Item).order_by(Item.collected_at.desc()).limit(limit)

        conditions = []

        # Status filter
        if status_filter == "starred":
            conditions.append(Item.starred == True)
        elif status_filter == "unread":
            conditions.append(Item.status == ItemStatus.NEW)
        elif status_filter == "read":
            conditions.append(Item.status == ItemStatus.READ)
        elif status_filter == "archived":
            conditions.append(Item.status == ItemStatus.ARCHIVED)

        # Date range filter
        if date_from:
            dt_from = datetime(date_from.year, date_from.month, date_from.day, tzinfo=timezone.utc)
            conditions.append(Item.collected_at >= dt_from)
        if date_to:
            dt_to = datetime(date_to.year, date_to.month, date_to.day, 23, 59, 59, tzinfo=timezone.utc)
            conditions.append(Item.collected_at <= dt_to)

        # Search filter
        if search:
            search_pattern = f"%{search}%"
            conditions.append(
                (Item.title.ilike(search_pattern)) |
                (Item.content.ilike(search_pattern))
            )

        if conditions:
            query = query.where(and_(*conditions))

        result = await session.execute(query)
        items = result.scalars().all()

        # Get sources dict
        source_ids = set(item.source_id for item in items)
        sources_dict = {}
        if source_ids:
            result = await session.execute(
                select(Source).where(Source.id.in_(source_ids))
            )
            for source in result.scalars().all():
                sources_dict[source.id] = source

        return items, sources_dict

# Page configuration
st.set_page_config(
    page_title="SentinelPi",
    page_icon="ðŸ›¡ï¸",
    layout="wide",
    initial_sidebar_state="expanded",
)


def init_session_state() -> None:
    """Initialize session state variables."""
    if "initialized" not in st.session_state:
        st.session_state.initialized = True
        st.session_state.current_page = "feed"
        st.session_state.selected_source = None
        st.session_state.selected_category = "all"
        st.session_state.search_query = ""
        st.session_state.date_filter = "all"
        st.session_state.status_filter = "all"

        # Sync sources and filters from YAML to database on first load
        try:
            sources_count = run_async(sync_sources_from_yaml())
            log.info(f"Synced {sources_count} sources from YAML to database")
        except Exception as e:
            log.error(f"Failed to sync sources: {e}")

        try:
            filters_count = run_async(sync_filters_from_yaml())
            log.info(f"Synced {filters_count} filters from YAML to database")
        except Exception as e:
            log.error(f"Failed to sync filters: {e}")


def render_sidebar() -> str:
    """Render the sidebar navigation."""
    with st.sidebar:
        st.markdown("### ðŸ›¡ï¸ SentinelPi")
        st.success("â— En ligne", icon="âœ…")

        st.divider()

        # Navigation
        page = st.radio(
            "Navigation",
            options=["feed", "sources", "filters", "alerts", "stats", "settings"],
            format_func=lambda x: {
                "feed": "ðŸ“° Flux",
                "sources": "ðŸ“¡ Sources",
                "filters": "ðŸŽ¯ Filtres",
                "alerts": "ðŸ”” Alertes",
                "stats": "ðŸ“Š Stats",
                "settings": "âš™ï¸ Config",
            }.get(x, x),
            label_visibility="collapsed",
        )

        st.divider()

        # Compact quick stats from database
        try:
            sidebar_stats = run_async(_get_sidebar_stats())
        except Exception:
            sidebar_stats = {"sources": 0, "items_24h": 0, "alerts": 0, "unread": 0}

        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.caption("**Src**")
            st.caption(str(sidebar_stats["sources"]))
        with col2:
            st.caption("**Items**")
            st.caption(str(sidebar_stats["items_24h"]))
        with col3:
            st.caption("**Alertes**")
            st.caption(str(sidebar_stats["alerts"]))
        with col4:
            st.caption("**NonLu**")
            st.caption(str(sidebar_stats["unread"]))

        settings = get_settings()
        st.caption(f"v{settings.app.version}")

        return page


def render_feed_page() -> None:
    """Render the main feed page."""
    st.header("ðŸ“° Flux d'actualitÃ©s")

    from datetime import date as date_type, timedelta as td

    today = date_type.today()

    # Filters row
    col1, col2, col3, col4, col5 = st.columns([2, 1.2, 1.2, 2, 0.4])

    with col1:
        search = st.text_input(
            "ðŸ” Rechercher",
            placeholder="Mots-clÃ©s...",
            label_visibility="collapsed",
        )

    with col2:
        status_filter = st.selectbox(
            "Statut",
            options=["all", "unread", "starred", "read", "archived"],
            format_func=lambda x: {
                "all": "Tous",
                "unread": "ðŸ†• Non lus",
                "starred": "â­ Favoris",
                "read": "âœ… Lus",
                "archived": "ðŸ“ Archives",
            }.get(x, x),
            label_visibility="collapsed",
        )

    with col3:
        category = st.selectbox(
            "CatÃ©gorie",
            options=["all", "presse", "tech", "social", "veille"],
            format_func=lambda x: "Toutes cat." if x == "all" else x.capitalize(),
            label_visibility="collapsed",
        )

    with col4:
        default_range = (today - td(days=7), today)
        date_range = st.date_input(
            "ðŸ“… Periode",
            value=default_range,
            max_value=today,
            label_visibility="collapsed",
        )

    with col5:
        if st.button("ðŸ”„", use_container_width=True, help="Actualiser"):
            st.rerun()

    # Parse range (can be single date or tuple)
    if isinstance(date_range, (list, tuple)) and len(date_range) == 2:
        date_from, date_to = date_range
    elif isinstance(date_range, (list, tuple)) and len(date_range) == 1:
        date_from = date_range[0]
        date_to = today
    else:
        date_from = date_range
        date_to = today

    st.divider()

    # Load items from database
    items, sources_dict = run_async(get_feed_items(
        search=search if search else None,
        category=category if category != "all" else None,
        date_from=date_from,
        date_to=date_to,
        status_filter=status_filter if status_filter != "all" else None,
    ))

    if items:
        st.caption(f"{len(items)} items")
        from src.dashboard.components.feed import render_feed
        render_feed(items, sources_dict)
    else:
        st.info("ðŸ“­ Aucun item Ã  afficher.", icon="â„¹ï¸")
        with st.expander("ðŸ’¡ Comment dÃ©marrer", expanded=True):
            st.markdown("""
            1. **Ajoutez des sources** dans l'onglet ðŸ“¡ Sources
            2. **Configurez des filtres** dans l'onglet ðŸŽ¯ Filtres
            3. **Lancez la collecte** avec la commande `sentinelpi`
            4. Les nouveaux articles apparaÃ®tront ici automatiquement
            """)


def render_sources_page() -> None:
    """Render the sources management page."""
    st.header("ðŸ“¡ Gestion des sources")

    # Load sources from database
    sources = run_async(get_all_sources())

    # Action buttons
    col1, col2, col3 = st.columns([1, 1, 4])
    with col1:
        if st.button("âž• Ajouter", use_container_width=True):
            st.session_state.show_add_source = True
    with col2:
        if st.button("ðŸ”„ RafraÃ®chir", use_container_width=True):
            st.rerun()

    # Add source form (above table)
    if st.session_state.get("show_add_source"):
        with st.form("add_source_form"):
            st.subheader("Ajouter une source")

            source_type = st.selectbox(
                "Type",
                options=["rss", "web", "reddit", "mastodon", "youtube"],
            )

            name = st.text_input("Nom", placeholder="Ma nouvelle source")
            url = st.text_input("URL", placeholder="https://...")
            category = st.text_input("CatÃ©gorie", placeholder="tech, presse, etc.")
            interval = st.number_input("Intervalle (minutes)", min_value=5, value=60)

            col1, col2 = st.columns(2)
            with col1:
                if st.form_submit_button("ðŸ’¾ Enregistrer", use_container_width=True):
                    if name and url:
                        try:
                            import hashlib
                            from src.storage.models import Source, SourceType

                            source_key = f"{name}:{url}"
                            source_id = hashlib.sha256(source_key.encode()).hexdigest()[:32]

                            new_source = Source()
                            new_source.id = source_id
                            new_source.name = name
                            new_source.type = SourceType(source_type)
                            new_source.url = url
                            new_source.category = category if category else None
                            new_source.interval_minutes = interval
                            new_source.enabled = True
                            new_source.priority = 2
                            new_source.config = {}

                            run_async(add_source_to_db(new_source))
                            st.success(f"Source '{name}' ajoutÃ©e !")
                            st.session_state.show_add_source = False
                            st.rerun()
                        except Exception as e:
                            st.error(f"Erreur: {e}")
                    else:
                        st.warning("Nom et URL requis")
            with col2:
                if st.form_submit_button("âŒ Annuler", use_container_width=True):
                    st.session_state.show_add_source = False

    st.divider()

    if sources:
        from src.dashboard.components.sources import (
            get_source_type_icon, get_status_badge,
            _run_async as _src_async, _toggle_source, _test_source,
        )

        # Table header
        h_icon, h_name, h_url, h_int, h_cat, h_status, h_last, h_tog, h_test = st.columns(
            [0.4, 1.8, 2.5, 0.6, 0.8, 1, 0.9, 0.7, 0.7]
        )
        with h_icon:
            st.caption("**Type**")
        with h_name:
            st.caption("**Nom**")
        with h_url:
            st.caption("**URL**")
        with h_int:
            st.caption("**Interv.**")
        with h_cat:
            st.caption("**Cat.**")
        with h_status:
            st.caption("**Statut**")
        with h_last:
            st.caption("**Check**")
        with h_tog:
            st.caption("**On/Off**")
        with h_test:
            st.caption("**Test**")

        # Render each source as a compact row with inline actions
        for s in sources:
            stype = s.type.value if hasattr(s.type, "value") else s.type
            icon = get_source_type_icon(stype)
            status = get_status_badge(s)
            last = "-"
            if s.last_check:
                from src.utils.dates import format_relative
                last = format_relative(s.last_check) if hasattr(s.last_check, "timestamp") else str(s.last_check)

            c_icon, c_name, c_url, c_int, c_cat, c_status, c_last, c_tog, c_test = st.columns(
                [0.4, 1.8, 2.5, 0.6, 0.8, 1, 0.9, 0.7, 0.7]
            )
            with c_icon:
                st.markdown(icon)
            with c_name:
                st.markdown(f"**{s.name}**")
            with c_url:
                short_url = s.url[:45] + "..." if len(s.url) > 45 else s.url
                st.caption(short_url)
            with c_int:
                st.caption(f"{s.interval_minutes} min")
            with c_cat:
                st.caption(s.category or "-")
            with c_status:
                st.caption(status)
            with c_last:
                st.caption(last)
            with c_tog:
                label = "â–¶ï¸" if not s.enabled else "â¸ï¸"
                if st.button(label, key=f"tog_{s.id}", help="Activer/Pause"):
                    _src_async(_toggle_source(s.id, s.enabled))
                    st.rerun()
            with c_test:
                if st.button("ðŸ”„", key=f"tst_{s.id}", help="Tester"):
                    with st.spinner("..."):
                        success, msg = _src_async(_test_source(s.id))
                        if success:
                            st.toast(f"OK: {msg}")
                        else:
                            st.error(msg)
    else:
        st.info("Aucune source configuree.")


def render_filters_page() -> None:
    """Render the filters configuration page."""
    st.header("ðŸŽ¯ Configuration des filtres")

    # Load filters from database
    filters = run_async(get_all_filters())

    col1, col2 = st.columns([1, 5])
    with col1:
        if st.button("âž• Nouveau filtre", use_container_width=True):
            st.session_state.show_add_filter = not st.session_state.get("show_add_filter", False)
            st.rerun()

    # Add filter form (hidden by default)
    if st.session_state.get("show_add_filter", False):
        with st.form("add_filter_form"):
            st.subheader("Nouveau filtre")
            col1, col2 = st.columns(2)
            with col1:
                nf_name = st.text_input("Nom", placeholder="Mon filtre")
                nf_desc = st.text_input("Description", placeholder="Ce filtre...")
                nf_action = st.selectbox("Action", options=["alert", "highlight", "tag", "exclude", "include"])
            with col2:
                nf_score = st.number_input("Modificateur score", value=0, step=5)
                nf_priority = st.number_input("Priorite", value=50, min_value=1)
                nf_field = st.selectbox("Champ", options=["all", "title", "content", "author"])

            nf_keywords = st.text_area("Mots-cles (un par ligne ou virgules)", placeholder="mot1\nmot2", height=100)

            # Action params
            nf_ap = {}
            if nf_action == "alert":
                nf_severity = st.selectbox("Severite", options=["info", "notice", "warning", "critical"], index=1)
                nf_ap["severity"] = nf_severity
            elif nf_action == "tag":
                nf_tag = st.text_input("Nom du tag", placeholder="mon-tag")
                nf_ap["tag"] = nf_tag

            c1, c2 = st.columns(2)
            with c1:
                if st.form_submit_button("ðŸ’¾ Enregistrer", use_container_width=True):
                    if nf_name and nf_keywords.strip():
                        import hashlib
                        kw_list = [k.strip() for line in nf_keywords.split("\n") for k in line.split(",") if k.strip()]
                        new_cond = {"type": "keywords", "field": nf_field, "operator": "contains", "case_sensitive": False, "value": kw_list}

                        from src.storage.models import Filter, FilterAction
                        flt = Filter()
                        flt.id = hashlib.sha256(nf_name.encode()).hexdigest()[:32]
                        flt.name = nf_name
                        flt.description = nf_desc or None
                        flt.action = FilterAction(nf_action)
                        flt.action_params = nf_ap
                        flt.conditions = new_cond
                        flt.score_modifier = nf_score
                        flt.priority = nf_priority
                        flt.enabled = True

                        run_async(add_source_to_db(flt))
                        st.session_state.show_add_filter = False
                        st.rerun()
                    else:
                        st.warning("Nom et mots-cles requis")
            with c2:
                if st.form_submit_button("âŒ Annuler", use_container_width=True):
                    st.session_state.show_add_filter = False
                    st.rerun()

    st.divider()

    if filters:
        from src.dashboard.components.filters import (
            get_action_badge, _format_conditions_summary,
            _run_async as _flt_async, _toggle_filter, _delete_filter,
        )

        # Table header
        h_st, h_name, h_act, h_cond, h_score, h_pri, h_edit, h_tog, h_del = st.columns(
            [0.3, 1.8, 1, 2.8, 0.5, 0.5, 0.4, 0.4, 0.4]
        )
        with h_st:
            st.caption("**On**")
        with h_name:
            st.caption("**Nom**")
        with h_act:
            st.caption("**Action**")
        with h_cond:
            st.caption("**Conditions**")
        with h_score:
            st.caption("**Score**")
        with h_pri:
            st.caption("**Prio**")
        with h_edit:
            st.caption("**Edit**")
        with h_tog:
            st.caption("**On/Off**")
        with h_del:
            st.caption("**Suppr**")

        for f in filters:
            action_val = f.action.value if hasattr(f.action, "value") else f.action
            badge = get_action_badge(action_val)
            cond_summary = _format_conditions_summary(f.conditions or {})
            score_str = f"{f.score_modifier:+}" if f.score_modifier else "0"
            status_icon = "âœ…" if f.enabled else "â¸ï¸"

            c_st, c_name, c_act, c_cond, c_score, c_pri, c_edit, c_tog, c_del = st.columns(
                [0.3, 1.8, 1, 2.8, 0.5, 0.5, 0.4, 0.4, 0.4]
            )
            with c_st:
                st.markdown(status_icon)
            with c_name:
                st.markdown(f"**{f.name}**")
                if f.description:
                    st.caption(f.description[:50])
            with c_act:
                st.caption(badge)
            with c_cond:
                if cond_summary:
                    st.caption(cond_summary[:70])
            with c_score:
                st.caption(score_str)
            with c_pri:
                st.caption(str(f.priority))
            with c_edit:
                if st.button("âœï¸", key=f"fedit_{f.id}", help="Modifier"):
                    st.session_state.editing_filter = f.id
            with c_tog:
                label = "â–¶ï¸" if not f.enabled else "â¸ï¸"
                if st.button(label, key=f"ftog_{f.id}", help="Activer/Pause"):
                    _flt_async(_toggle_filter(f.id, f.enabled))
                    st.rerun()
            with c_del:
                if st.button("ðŸ—‘", key=f"fdel_{f.id}", help="Supprimer"):
                    _flt_async(_delete_filter(f.id))
                    st.rerun()

        # Edit filter form
        editing_id = st.session_state.get("editing_filter")
        if editing_id:
            edit_f = next((f for f in filters if f.id == editing_id), None)
            if edit_f:
                st.divider()
                action_val = edit_f.action.value if hasattr(edit_f.action, "value") else edit_f.action
                cond = edit_f.conditions or {}
                cond_value = cond.get("value", [])
                if isinstance(cond_value, list):
                    kw_text = "\n".join(cond_value)
                else:
                    kw_text = str(cond_value)

                with st.form(f"edit_filter_{editing_id}"):
                    st.subheader(f"Modifier : {edit_f.name}")
                    col1, col2 = st.columns(2)
                    with col1:
                        ef_name = st.text_input("Nom", value=edit_f.name)
                        ef_desc = st.text_input("Description", value=edit_f.description or "")
                        ef_action = st.selectbox(
                            "Action",
                            options=["alert", "highlight", "tag", "exclude", "include"],
                            index=["alert", "highlight", "tag", "exclude", "include"].index(action_val) if action_val in ["alert", "highlight", "tag", "exclude", "include"] else 0,
                        )
                    with col2:
                        ef_score = st.number_input("Modificateur score", value=int(edit_f.score_modifier), step=5)
                        ef_priority = st.number_input("Priorite", value=edit_f.priority, min_value=1)
                        ef_enabled = st.checkbox("Actif", value=edit_f.enabled)

                    ef_keywords = st.text_area("Mots-cles (un par ligne)", value=kw_text, height=120)

                    # Action params
                    ap = edit_f.action_params or {}
                    if ef_action == "alert":
                        ef_severity = st.selectbox("Severite", options=["info", "notice", "warning", "critical"],
                            index=["info", "notice", "warning", "critical"].index(ap.get("severity", "notice")))
                    elif ef_action == "tag":
                        ef_tag = st.text_input("Tag", value=ap.get("tag", ""))

                    c1, c2 = st.columns(2)
                    with c1:
                        if st.form_submit_button("ðŸ’¾ Sauvegarder", use_container_width=True):
                            # Parse keywords
                            new_kw = [k.strip() for line in ef_keywords.split("\n") for k in line.split(",") if k.strip()]
                            new_cond = dict(cond)
                            new_cond["value"] = new_kw

                            new_ap = {}
                            if ef_action == "alert":
                                new_ap["severity"] = ef_severity
                            elif ef_action == "tag":
                                new_ap["tag"] = ef_tag

                            run_async(_update_filter_db(
                                editing_id, ef_name, ef_desc, ef_action,
                                new_ap, new_cond, ef_score, ef_priority, ef_enabled
                            ))
                            st.session_state.editing_filter = None
                            st.rerun()
                    with c2:
                        if st.form_submit_button("âŒ Annuler", use_container_width=True):
                            st.session_state.editing_filter = None
                            st.rerun()
    else:
        st.info("Aucun filtre configure.")


def render_alerts_page() -> None:
    """Render the alerts history page."""
    st.header("ðŸ”” Historique des alertes")

    # Filters
    col1, col2, col3 = st.columns([2, 2, 2])

    with col1:
        severity = st.selectbox(
            "SÃ©vÃ©ritÃ©",
            options=["all", "critical", "warning", "notice", "info"],
            format_func=lambda x: {
                "all": "Toutes",
                "critical": "ðŸš¨ Critique",
                "warning": "âš ï¸ Attention",
                "notice": "ðŸ“¢ Notice",
                "info": "â„¹ï¸ Info",
            }.get(x, x),
        )

    with col2:
        date_range = st.selectbox(
            "PÃ©riode",
            options=["today", "week", "month", "all"],
            format_func=lambda x: {
                "today": "Aujourd'hui",
                "week": "Cette semaine",
                "month": "Ce mois",
                "all": "Tout",
            }.get(x, x),
        )

    with col3:
        if st.button("ðŸ”„ Actualiser", use_container_width=True):
            st.rerun()

    st.divider()

    # Load alerts
    alerts = run_async(get_all_alerts(
        severity_filter=severity if severity != "all" else None,
        date_filter=date_range if date_range != "all" else None,
    ))

    if alerts:
        st.caption(f"{len(alerts)} alertes")
        from src.dashboard.components.alerts import render_alert_card
        for alert in alerts:
            render_alert_card(alert, show_actions=True)
    else:
        st.info("ðŸ“­ Aucune alerte enregistrÃ©e.", icon="â„¹ï¸")


def render_stats_page() -> None:
    """Render the statistics page."""
    st.header("ðŸ“Š Statistiques")

    # Time period selector
    period = st.selectbox(
        "PÃ©riode",
        options=["week", "month", "quarter", "year"],
        format_func=lambda x: {
            "week": "7 derniers jours",
            "month": "30 derniers jours",
            "quarter": "3 derniers mois",
            "year": "12 derniers mois",
        }.get(x, x),
    )

    st.divider()

    # Load stats
    stats = run_async(get_stats(period))

    # Metrics row
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric(
            "Items collectÃ©s",
            stats["items_count"],
            help="Total des items collectÃ©s sur la pÃ©riode",
        )

    with col2:
        st.metric(
            "Alertes dÃ©clenchÃ©es",
            stats["alerts_count"],
            help="Alertes envoyÃ©es sur la pÃ©riode",
        )

    with col3:
        st.metric(
            "Sources actives",
            stats["sources_count"],
            help="Sources activÃ©es",
        )

    with col4:
        avg_score = 0
        if stats["top_items"]:
            avg_score = sum(i.relevance_score for i in stats["top_items"]) / len(stats["top_items"])
        st.metric(
            "Score moyen",
            f"{avg_score:.0f}",
            help="Score moyen des top items",
        )

    st.divider()

    # Charts
    col1, col2 = st.columns(2)

    with col1:
        st.subheader("ðŸ“Š RÃ©partition par source")
        if stats["items_by_source"]:
            import pandas as pd
            df = pd.DataFrame(stats["items_by_source"], columns=["Source", "Items"])
            st.bar_chart(df.set_index("Source"))
        else:
            st.info("Pas assez de donnÃ©es.")

    with col2:
        st.subheader("ðŸ† Top 10 items (par score)")
        if stats["top_items"]:
            for i, item in enumerate(stats["top_items"][:10], 1):
                score_color = "ðŸŸ¢" if item.relevance_score > 70 else "ðŸŸ¡" if item.relevance_score > 40 else "âšª"
                title = item.title[:50] + "..." if len(item.title) > 50 else item.title
                st.markdown(f"{i}. {score_color} **{item.relevance_score:.0f}** - {title}")
        else:
            st.info("Aucun item Ã  afficher.")


def _save_settings_yaml(data: dict) -> None:
    """Save settings dict to YAML file."""
    import yaml
    from src.utils.config import PROJECT_ROOT
    settings_path = PROJECT_ROOT / "config" / "settings.yaml"
    with open(settings_path, "w", encoding="utf-8") as f:
        yaml.dump(data, f, default_flow_style=False, allow_unicode=True, sort_keys=False)


def _load_settings_yaml() -> dict:
    """Load raw settings dict from YAML."""
    import yaml
    from src.utils.config import PROJECT_ROOT
    settings_path = PROJECT_ROOT / "config" / "settings.yaml"
    with open(settings_path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)


def render_settings_page() -> None:
    """Render the settings page with editable fields."""
    st.header("âš™ï¸ Parametres")

    raw = _load_settings_yaml()

    with st.form("settings_form"):
        tabs = st.tabs(["ðŸ”§ General", "ðŸ“¡ Collecte", "ðŸ”” Alertes", "ðŸ—„ï¸ Base de donnees", "ðŸ“‹ Logs", "ðŸ›  Maintenance"])

        with tabs[0]:
            col1, col2 = st.columns(2)
            with col1:
                app_name = st.text_input("Nom", value=raw.get("app", {}).get("name", "SentinelPi"))
                app_tz = st.text_input("Fuseau horaire", value=raw.get("app", {}).get("timezone", "Europe/Paris"))
            with col2:
                app_version = st.text_input("Version", value=raw.get("app", {}).get("version", "1.0.0"))
                log_level = st.selectbox(
                    "Niveau de log",
                    options=["DEBUG", "INFO", "WARNING", "ERROR"],
                    index=["DEBUG", "INFO", "WARNING", "ERROR"].index(
                        raw.get("logging", {}).get("level", "INFO")
                    ),
                )

        with tabs[1]:
            col1, col2 = st.columns(2)
            coll = raw.get("collection", {})
            with col1:
                coll_interval = st.number_input("Intervalle par defaut (min)", value=coll.get("default_interval_minutes", 60), min_value=5)
                coll_concurrent = st.number_input("Collecteurs simultanes", value=coll.get("max_concurrent_collectors", 3), min_value=1, max_value=10)
                coll_timeout = st.number_input("Timeout collecteur (s)", value=coll.get("collector_timeout", 120), min_value=10)
            with col2:
                coll_max_items = st.number_input("Items max par source", value=coll.get("max_items_per_source", 100), min_value=10)
                coll_dedup = st.number_input("Fenetre dedup (jours)", value=coll.get("dedup_window_days", 30), min_value=1)

            st.divider()
            http = raw.get("http", {})
            col1, col2 = st.columns(2)
            with col1:
                http_timeout = st.number_input("HTTP timeout (s)", value=http.get("timeout", 30), min_value=5)
                http_retries = st.number_input("HTTP retries", value=http.get("max_retries", 3), min_value=0)
            with col2:
                http_rate = st.number_input("Rate limit (req/s)", value=http.get("rate_limit", 2), min_value=1)
                http_ua = st.text_input("User-Agent", value=http.get("user_agent", ""))

        with tabs[2]:
            st.caption("Les tokens sont dans le fichier `.env`")
            sched = raw.get("scheduler", {})
            col1, col2 = st.columns(2)
            with col1:
                sched_enabled = st.checkbox("Scheduler actif", value=sched.get("enabled", True))
                daily_time = st.text_input("Rapport quotidien (HH:MM)", value=sched.get("daily_report_time", "08:00"))
            with col2:
                weekly_day = st.number_input("Jour rapport hebdo (0=lun)", value=sched.get("weekly_report_day", 0), min_value=0, max_value=6)
                weekly_time = st.text_input("Heure rapport hebdo", value=sched.get("weekly_report_time", "09:00"))

        with tabs[3]:
            db = raw.get("database", {})
            db_path = st.text_input("Chemin DB", value=db.get("path", "data/sentinelpi.db"))
            db_echo = st.checkbox("Afficher SQL (debug)", value=db.get("echo", False))

        with tabs[4]:
            log = raw.get("logging", {})
            col1, col2 = st.columns(2)
            with col1:
                log_file = st.text_input("Fichier log", value=log.get("file", "logs/sentinelpi.log"))
                log_rotation = st.text_input("Rotation", value=log.get("rotation", "10 MB"))
            with col2:
                log_retention = st.text_input("Retention", value=log.get("retention", "30 days"))
                log_colorize = st.checkbox("Couleurs console", value=log.get("colorize", True))

        with tabs[5]:
            maint = raw.get("maintenance", {})
            col1, col2 = st.columns(2)
            with col1:
                maint_cleanup = st.checkbox("Nettoyage auto", value=maint.get("cleanup_enabled", True))
                maint_retention = st.number_input("Retention items (jours)", value=maint.get("retention_days", 90), min_value=1)
            with col2:
                maint_time = st.text_input("Heure nettoyage", value=maint.get("cleanup_time", "03:00"))
                maint_vacuum = st.checkbox("Vacuum hebdo", value=maint.get("vacuum_enabled", True))

        if st.form_submit_button("ðŸ’¾ Sauvegarder", use_container_width=True):
            new_config = {
                "app": {"name": app_name, "version": app_version, "timezone": app_tz},
                "database": {"path": db_path, "echo": db_echo},
                "http": {
                    "timeout": http_timeout, "max_retries": http_retries,
                    "retry_delay": raw.get("http", {}).get("retry_delay", 5),
                    "user_agent": http_ua, "rate_limit": http_rate,
                    "cache": raw.get("http", {}).get("cache", {}),
                },
                "collection": {
                    "default_interval_minutes": coll_interval,
                    "max_concurrent_collectors": coll_concurrent,
                    "max_items_per_source": coll_max_items,
                    "dedup_window_days": coll_dedup,
                    "collector_timeout": coll_timeout,
                },
                "processing": raw.get("processing", {}),
                "scheduler": {
                    "enabled": sched_enabled,
                    "check_interval_seconds": sched.get("check_interval_seconds", 60),
                    "daily_report_time": daily_time,
                    "weekly_report_day": weekly_day,
                    "weekly_report_time": weekly_time,
                },
                "dashboard": raw.get("dashboard", {}),
                "logging": {
                    "level": log_level, "file": log_file,
                    "rotation": log_rotation, "retention": log_retention,
                    "format": log.get("format", ""),
                    "colorize": log_colorize,
                },
                "maintenance": {
                    "cleanup_enabled": maint_cleanup,
                    "retention_days": maint_retention,
                    "cleanup_time": maint_time,
                    "vacuum_enabled": maint_vacuum,
                },
            }
            try:
                _save_settings_yaml(new_config)
                st.success("Parametres sauvegardes ! Redemarrez l'application pour appliquer.")
            except Exception as e:
                st.error(f"Erreur: {e}")

    # Restart button (outside form)
    st.divider()
    st.subheader("Redemarrage")
    st.caption("Redemarrer l'application pour appliquer les changements de configuration.")
    if st.button("ðŸ”„ Redemarrer l'application", type="primary"):
        import subprocess, sys, os, time
        st.cache_data.clear()
        st.cache_resource.clear()
        project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
        subprocess.Popen(
            [sys.executable, "-m", "streamlit", "run",
             os.path.abspath(__file__),
             "--server.port=8501", "--server.address=0.0.0.0", "--server.headless=true"],
            cwd=project_root
        )
        st.info("Redemarrage en cours... La page va se recharger automatiquement.")
        time.sleep(1)
        os._exit(0)


def main() -> None:
    """Main entry point for the dashboard."""
    # Initialize
    setup_logging()
    init_session_state()

    # Custom CSS
    st.markdown("""
    <style>
    .stMetric {
        background-color: #f0f2f6;
        padding: 10px;
        border-radius: 5px;
    }
    .stDataFrame {
        font-size: 14px;
    }
    </style>
    """, unsafe_allow_html=True)

    # Render sidebar and get selected page
    page = render_sidebar()

    # Render selected page
    if page == "feed":
        render_feed_page()
    elif page == "sources":
        render_sources_page()
    elif page == "filters":
        render_filters_page()
    elif page == "alerts":
        render_alerts_page()
    elif page == "stats":
        render_stats_page()
    elif page == "settings":
        render_settings_page()


if __name__ == "__main__":
    main()
