"""Notifications Telegram pour StratWatch.

Envoie les alertes via un bot Telegram.
"""

import asyncio
from typing import Optional

from src.config import get_settings
from src.storage.models import Alert, SEVERITY_ORDER
from src.utils.logging import get_logger

logger = get_logger(__name__)


# Emojis par s√©v√©rit√©
SEVERITY_EMOJI = {
    "info": "‚ÑπÔ∏è",
    "attention": "‚ö†Ô∏è",
    "important": "üî∂",
    "critique": "üö®",
}

# Emojis par cat√©gorie
CATEGORY_EMOJI = {
    "concurrent": "üè¢",
    "reglementaire": "üìú",
    "croisee": "üîó",
}


class TelegramNotifier:
    """Gestionnaire de notifications Telegram.

    Envoie des alertes format√©es via l'API Telegram Bot.

    Example:
        notifier = TelegramNotifier()
        await notifier.send_alert(alert)
    """

    def __init__(
        self,
        bot_token: Optional[str] = None,
        chat_id: Optional[str] = None,
    ) -> None:
        """Initialise le notifier Telegram.

        Args:
            bot_token: Token du bot Telegram.
            chat_id: ID du chat/groupe cible.
        """
        settings = get_settings()

        self._bot_token = bot_token or settings.telegram_bot_token
        self._chat_id = chat_id or settings.telegram_chat_id
        self._enabled = settings.alerting.channels.telegram.enabled
        self._min_severity = settings.alerting.channels.telegram.min_severity
        self._bot = None
        self._logger = get_logger("alerting.telegram")

    def _check_config(self) -> bool:
        """V√©rifie que la configuration est compl√®te.

        Returns:
            True si configur√©, False sinon.
        """
        if not self._enabled:
            self._logger.debug("Notifications Telegram d√©sactiv√©es")
            return False

        if not self._bot_token:
            self._logger.warning("Token Telegram non configur√©")
            return False

        if not self._chat_id:
            self._logger.warning("Chat ID Telegram non configur√©")
            return False

        return True

    async def _get_bot(self):
        """R√©cup√®re ou cr√©e l'instance du bot.

        Returns:
            Instance du bot Telegram.
        """
        if self._bot is None:
            try:
                from telegram import Bot
                self._bot = Bot(token=self._bot_token)
            except ImportError:
                self._logger.error("python-telegram-bot non install√©")
                raise

        return self._bot

    def _format_alert(self, alert: Alert) -> str:
        """Formate une alerte en message Telegram.

        Args:
            alert: Alerte √† formater.

        Returns:
            Message format√© en Markdown.
        """
        severity_emoji = SEVERITY_EMOJI.get(alert.severite, "üìå")
        category_emoji = CATEGORY_EMOJI.get(alert.categorie, "üìã")

        # En-t√™te
        lines = [
            f"{severity_emoji} *{alert.titre}*",
            "",
        ]

        # Corps du message
        message = alert.message
        if len(message) > 500:
            message = message[:497] + "..."

        # √âchapper les caract√®res sp√©ciaux Markdown
        message = self._escape_markdown(message)
        lines.append(message)

        # M√©tadonn√©es
        lines.append("")
        lines.append(f"{category_emoji} _{alert.categorie.capitalize()}_")

        # Lien source
        if alert.source_url:
            lines.append(f"üîó [Voir la source]({alert.source_url})")

        # Timestamp
        time_str = alert.created_at.strftime("%d/%m/%Y %H:%M")
        lines.append(f"üïê {time_str}")

        return "\n".join(lines)

    def _escape_markdown(self, text: str) -> str:
        """√âchappe les caract√®res sp√©ciaux Markdown.

        Args:
            text: Texte √† √©chapper.

        Returns:
            Texte √©chapp√©.
        """
        special_chars = ["_", "*", "[", "]", "(", ")", "~", "`", ">", "#", "+", "-", "=", "|", "{", "}", ".", "!"]
        for char in special_chars:
            text = text.replace(char, f"\\{char}")
        return text

    def _should_send(self, alert: Alert) -> bool:
        """V√©rifie si l'alerte doit √™tre envoy√©e.

        Args:
            alert: Alerte √† v√©rifier.

        Returns:
            True si l'alerte doit √™tre envoy√©e.
        """
        min_level = SEVERITY_ORDER.get(self._min_severity, 0)
        alert_level = SEVERITY_ORDER.get(alert.severite, 0)
        return alert_level >= min_level

    async def send_alert(self, alert: Alert) -> bool:
        """Envoie une alerte via Telegram.

        Args:
            alert: Alerte √† envoyer.

        Returns:
            True si envoy√© avec succ√®s.
        """
        if not self._check_config():
            return False

        if not self._should_send(alert):
            self._logger.debug(f"Alerte ignor√©e (s√©v√©rit√© {alert.severite})")
            return False

        try:
            bot = await self._get_bot()
            message = self._format_alert(alert)

            await bot.send_message(
                chat_id=self._chat_id,
                text=message,
                parse_mode="Markdown",
                disable_web_page_preview=True,
            )

            self._logger.info(f"Alerte envoy√©e: {alert.titre}")
            return True

        except Exception as e:
            self._logger.error(f"Erreur envoi Telegram: {e}")
            return False

    async def send_alerts_batch(self, alerts: list[Alert]) -> tuple[int, int]:
        """Envoie un lot d'alertes.

        Args:
            alerts: Liste des alertes.

        Returns:
            Tuple (envoy√©es, √©chou√©es).
        """
        if not self._check_config():
            return (0, len(alerts))

        sent = 0
        failed = 0

        for alert in alerts:
            success = await self.send_alert(alert)
            if success:
                sent += 1
            else:
                failed += 1

            # Rate limiting: max 30 messages/seconde pour Telegram
            await asyncio.sleep(0.05)

        self._logger.info(f"Lot envoy√©: {sent} succ√®s, {failed} √©checs")
        return (sent, failed)

    async def send_digest(
        self,
        alerts: list[Alert],
        title: str = "R√©sum√© des alertes",
    ) -> bool:
        """Envoie un r√©sum√© group√© des alertes.

        Args:
            alerts: Liste des alertes.
            title: Titre du digest.

        Returns:
            True si envoy√© avec succ√®s.
        """
        if not self._check_config():
            return False

        if not alerts:
            return True

        # Grouper par s√©v√©rit√©
        by_severity = {"critique": [], "important": [], "attention": [], "info": []}
        for alert in alerts:
            if alert.severite in by_severity:
                by_severity[alert.severite].append(alert)

        # Construire le message
        lines = [f"üìä *{title}*", ""]

        for severity, severity_alerts in by_severity.items():
            if not severity_alerts:
                continue

            emoji = SEVERITY_EMOJI.get(severity, "üìå")
            lines.append(f"{emoji} *{severity.upper()}* ({len(severity_alerts)})")

            for alert in severity_alerts[:5]:  # Max 5 par cat√©gorie
                titre = self._escape_markdown(alert.titre[:50])
                lines.append(f"  ‚Ä¢ {titre}")

            if len(severity_alerts) > 5:
                lines.append(f"  _... et {len(severity_alerts) - 5} autres_")

            lines.append("")

        # Total
        lines.append(f"üìà Total: {len(alerts)} alertes")

        try:
            bot = await self._get_bot()
            await bot.send_message(
                chat_id=self._chat_id,
                text="\n".join(lines),
                parse_mode="Markdown",
            )
            return True

        except Exception as e:
            self._logger.error(f"Erreur envoi digest: {e}")
            return False

    async def send_test_message(self) -> bool:
        """Envoie un message de test.

        Returns:
            True si envoy√© avec succ√®s.
        """
        if not self._check_config():
            return False

        try:
            bot = await self._get_bot()
            await bot.send_message(
                chat_id=self._chat_id,
                text="‚úÖ *StratWatch* - Test de connexion r√©ussi!",
                parse_mode="Markdown",
            )
            self._logger.info("Message de test envoy√©")
            return True

        except Exception as e:
            self._logger.error(f"Erreur test Telegram: {e}")
            return False
