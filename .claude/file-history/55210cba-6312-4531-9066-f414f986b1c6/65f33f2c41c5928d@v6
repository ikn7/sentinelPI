"""Interface en ligne de commande pour StratWatch."""

import asyncio
import sys
from typing import Optional

import click

from src.config import get_settings, load_competitors, PROJECT_ROOT
from src.utils.logging import setup_logging, get_logger


@click.group()
@click.version_option(version="1.0.0", prog_name="StratWatch")
@click.option("--debug/--no-debug", default=False, help="Mode debug")
def main(debug: bool) -> None:
    """StratWatch - Plateforme de veille strat√©gique."""
    settings = get_settings()
    log_level = "DEBUG" if debug else settings.logging.level

    setup_logging(
        level=log_level,
        log_format=settings.logging.format,
        rotation=settings.logging.rotation,
        retention=settings.logging.retention,
        log_dir=settings.get_log_dir(),
    )


@main.group()
def db() -> None:
    """Commandes de gestion de la base de donn√©es."""
    pass


@db.command("init")
def db_init() -> None:
    """Initialise la base de donn√©es et cr√©e les tables."""
    from src.storage import init_database

    logger = get_logger("cli")
    logger.info("Initialisation de la base de donn√©es...")

    asyncio.run(init_database())

    logger.info("Base de donn√©es initialis√©e avec succ√®s")
    click.echo("Base de donn√©es initialis√©e.")


@db.command("reset")
@click.confirmation_option(prompt="√ätes-vous s√ªr de vouloir supprimer toutes les donn√©es ?")
def db_reset() -> None:
    """R√©initialise la base de donn√©es (supprime toutes les donn√©es)."""
    from src.storage import db, init_database

    logger = get_logger("cli")

    async def reset():
        await db.init()
        await db.drop_tables()
        await db.create_tables()
        await db.close()

    logger.warning("R√©initialisation de la base de donn√©es...")
    asyncio.run(reset())

    logger.info("Base de donn√©es r√©initialis√©e")
    click.echo("Base de donn√©es r√©initialis√©e.")


@main.group()
def collect() -> None:
    """Commandes de collecte de donn√©es."""
    pass


@collect.command("legal")
@click.option("--siren", "-s", help="SIREN sp√©cifique √† collecter")
@click.option("--all", "collect_all", is_flag=True, help="Collecter tous les concurrents configur√©s")
def collect_legal(siren: Optional[str], collect_all: bool) -> None:
    """Collecte les donn√©es l√©gales via Pappers."""
    from src.collectors import PappersCollector
    from src.storage import db

    logger = get_logger("cli")

    async def run_collection():
        await db.init()
        await db.create_tables()

        async with PappersCollector() as collector:
            async with db.session() as session:
                if siren:
                    result = await collector.collect_with_details(siren, session)
                    click.echo(f"Collecte termin√©e: {result.items_collected} √©l√©ments collect√©s, "
                              f"{result.items_saved} sauvegard√©s")
                elif collect_all:
                    competitors_config = load_competitors()
                    for comp in competitors_config.competitors:
                        result = await collector.collect_with_details(comp.siren, session)
                        click.echo(f"[{comp.siren}] {comp.nom}: {result.items_saved} √©l√©ments")
                else:
                    click.echo("Sp√©cifiez --siren ou --all")
                    return

        await db.close()

    logger.info("D√©marrage de la collecte des donn√©es l√©gales")
    asyncio.run(run_collection())


@collect.command("search")
@click.argument("query")
@click.option("--limit", "-n", default=10, help="Nombre de r√©sultats")
def collect_search(query: str, limit: int) -> None:
    """Recherche des entreprises par nom."""
    from src.collectors import PappersCollector

    logger = get_logger("cli")

    async def run_search():
        async with PappersCollector() as collector:
            results = await collector.search_companies(query, limit=limit)

            if not results:
                click.echo("Aucun r√©sultat trouv√©.")
                return

            click.echo(f"\n{len(results)} entreprise(s) trouv√©e(s):\n")
            for company in results:
                click.echo(f"  SIREN: {company['siren']}")
                click.echo(f"  Nom: {company['nom']}")
                click.echo(f"  Forme: {company['forme_juridique']}")
                click.echo(f"  NAF: {company['code_naf']}")
                click.echo(f"  Ville: {company['ville']}")
                click.echo("")

    logger.info(f"Recherche d'entreprises: {query}")
    asyncio.run(run_search())


@collect.command("bodacc")
@click.option("--siren", "-s", help="SIREN sp√©cifique √† surveiller")
@click.option("--all", "collect_all", is_flag=True, help="Collecter pour tous les concurrents")
def collect_bodacc(siren: Optional[str], collect_all: bool) -> None:
    """Collecte les annonces l√©gales BODACC."""
    from src.collectors import BodaccCollector
    from src.storage import db

    logger = get_logger("cli")

    async def run_collection():
        await db.init()
        await db.create_tables()

        async with BodaccCollector() as collector:
            async with db.session() as session:
                if siren:
                    result = await collector.collect_and_save(session, siren=siren)
                    click.echo(f"BODACC [{siren}]: {result.items_collected} annonces trouv√©es, "
                              f"{result.items_saved} nouvelles")
                elif collect_all:
                    result = await collector.collect_and_save(session)
                    click.echo(f"BODACC: {result.items_collected} annonces analys√©es, "
                              f"{result.items_saved} nouvelles sauvegard√©es")
                else:
                    click.echo("Sp√©cifiez --siren ou --all")
                    return

                if not result.success:
                    click.echo(f"Erreurs: {result.errors}")

        await db.close()

    logger.info("D√©marrage de la collecte BODACC")
    asyncio.run(run_collection())


@collect.command("regulations")
@click.option("--sector", "-s", help="Secteur sp√©cifique (ex: fintech, tech)")
@click.option("--all", "collect_all", is_flag=True, help="Collecter pour tous les secteurs actifs")
def collect_regulations(sector: Optional[str], collect_all: bool) -> None:
    """Collecte les textes r√©glementaires via L√©gifrance."""
    from src.collectors import LegifranceCollector
    from src.config import load_sectors
    from src.storage import db

    logger = get_logger("cli")

    async def run_collection():
        await db.init()
        await db.create_tables()

        async with LegifranceCollector() as collector:
            async with db.session() as session:
                if sector:
                    result = await collector.collect_and_save(session, sector_id=sector)
                    click.echo(f"L√©gifrance [{sector}]: {result.items_collected} textes trouv√©s, "
                              f"{result.items_saved} nouveaux")
                elif collect_all:
                    result = await collector.collect_and_save(session)
                    click.echo(f"L√©gifrance: {result.items_collected} textes analys√©s, "
                              f"{result.items_saved} nouveaux sauvegard√©s")
                else:
                    # Afficher les secteurs disponibles
                    sectors_config = load_sectors()
                    click.echo("\nSecteurs disponibles:")
                    for s in sectors_config.sectors:
                        status = "actif" if s.actif else "inactif"
                        click.echo(f"  - {s.id}: {s.nom} ({status})")
                    click.echo("\nUtilisez --sector <id> ou --all")
                    return

                if not result.success:
                    click.echo(f"Erreurs: {result.errors}")

        await db.close()

    logger.info("D√©marrage de la collecte r√©glementaire")
    asyncio.run(run_collection())


@collect.command("all")
def collect_all_sources() -> None:
    """Collecte toutes les sources de donn√©es."""
    from src.collectors import BodaccCollector, LegifranceCollector, PappersCollector
    from src.storage import db

    logger = get_logger("cli")

    async def run_all():
        await db.init()
        await db.create_tables()

        results = []

        # Pappers (donn√©es l√©gales)
        click.echo("\n[1/3] Collecte des donn√©es l√©gales (Pappers)...")
        try:
            async with PappersCollector() as collector:
                async with db.session() as session:
                    competitors_config = load_competitors()
                    for comp in competitors_config.competitors:
                        result = await collector.collect_with_details(comp.siren, session)
                        results.append(("Pappers", comp.siren, result))
        except Exception as e:
            click.echo(f"  Erreur Pappers: {e}")

        # BODACC
        click.echo("\n[2/3] Collecte des annonces BODACC...")
        try:
            async with BodaccCollector() as collector:
                async with db.session() as session:
                    result = await collector.collect_and_save(session)
                    results.append(("BODACC", "all", result))
        except Exception as e:
            click.echo(f"  Erreur BODACC: {e}")

        # L√©gifrance
        click.echo("\n[3/3] Collecte r√©glementaire (L√©gifrance)...")
        try:
            async with LegifranceCollector() as collector:
                async with db.session() as session:
                    result = await collector.collect_and_save(session)
                    results.append(("L√©gifrance", "all", result))
        except Exception as e:
            click.echo(f"  Erreur L√©gifrance: {e}")

        await db.close()

        # R√©sum√©
        click.echo("\n" + "=" * 50)
        click.echo("R√âSUM√â DE LA COLLECTE")
        click.echo("=" * 50)

        total_collected = 0
        total_saved = 0

        for source, target, result in results:
            status = "OK" if result.success else "ERREUR"
            click.echo(f"{source} [{target}]: {result.items_saved} nouveaux ({status})")
            total_collected += result.items_collected
            total_saved += result.items_saved

        click.echo("-" * 50)
        click.echo(f"Total: {total_collected} analys√©s, {total_saved} sauvegard√©s")

    logger.info("D√©marrage de la collecte compl√®te")
    asyncio.run(run_all())


@main.command("api")
@click.option("--host", "-h", default=None, help="H√¥te de l'API")
@click.option("--port", "-p", default=None, type=int, help="Port de l'API")
def api(host: Optional[str], port: Optional[int]) -> None:
    """D√©marre le serveur API."""
    import uvicorn

    settings = get_settings()
    host = host or settings.api.host
    port = port or settings.api.port

    logger = get_logger("cli")
    logger.info(f"D√©marrage de l'API sur {host}:{port}")

    click.echo(f"API StratWatch disponible sur http://{host}:{port}")
    click.echo(f"Documentation: http://{host}:{port}/docs")

    uvicorn.run(
        "src.api.app:app",
        host=host,
        port=port,
        reload=False,
    )


@main.command("dashboard")
@click.option("--host", "-h", default=None, help="H√¥te du dashboard")
@click.option("--port", "-p", default=None, type=int, help="Port du dashboard")
def dashboard(host: Optional[str], port: Optional[int]) -> None:
    """D√©marre le dashboard Streamlit."""
    import subprocess

    settings = get_settings()
    host = host or settings.dashboard.host
    port = port or settings.dashboard.port

    logger = get_logger("cli")
    logger.info(f"D√©marrage du dashboard sur {host}:{port}")

    click.echo(f"Dashboard StratWatch disponible sur http://{host}:{port}")

    dashboard_path = PROJECT_ROOT / "src" / "dashboard" / "app.py"
    subprocess.run([
        sys.executable, "-m", "streamlit", "run",
        str(dashboard_path),
        "--server.address", host,
        "--server.port", str(port),
    ])


@main.command("config")
@click.option("--show", is_flag=True, help="Affiche la configuration actuelle")
@click.option("--check", is_flag=True, help="V√©rifie la configuration")
def config(show: bool, check: bool) -> None:
    """Gestion de la configuration."""
    settings = get_settings()

    if show:
        click.echo("\n=== Configuration StratWatch ===\n")
        click.echo(f"Environnement: {settings.app.environment}")
        click.echo(f"Base de donn√©es: {settings.database.type}")
        click.echo(f"API Pappers: {'configur√©e' if settings.pappers_api_key else 'non configur√©e'}")
        click.echo(f"Telegram: {'activ√©' if settings.alerting.channels.telegram.enabled else 'd√©sactiv√©'}")
        click.echo(f"Email: {'activ√©' if settings.alerting.channels.email.enabled else 'd√©sactiv√©'}")
        click.echo("")

        competitors = load_competitors()
        click.echo(f"Concurrents surveill√©s: {len(competitors.competitors)}")

    if check:
        errors = []
        warnings = []

        if not settings.pappers_api_key:
            errors.append("Cl√© API Pappers non configur√©e (PAPPERS_API_KEY)")

        if settings.alerting.channels.telegram.enabled:
            if not settings.telegram_bot_token:
                warnings.append("Token Telegram non configur√©")
            if not settings.telegram_chat_id:
                warnings.append("Chat ID Telegram non configur√©")

        competitors = load_competitors()
        if not competitors.competitors:
            warnings.append("Aucun concurrent configur√© dans config/competitors.yaml")

        if errors:
            click.echo("\nErreurs:")
            for err in errors:
                click.echo(f"  - {err}")

        if warnings:
            click.echo("\nAvertissements:")
            for warn in warnings:
                click.echo(f"  - {warn}")

        if not errors and not warnings:
            click.echo("\nConfiguration OK")


@main.group()
def alerts() -> None:
    """Commandes de gestion des alertes."""
    pass


@alerts.command("process")
def alerts_process() -> None:
    """Traite et envoie les alertes en attente."""
    from src.alerting import NotificationDispatcher
    from src.storage import db

    logger = get_logger("cli")

    async def run_process():
        await db.init()
        await db.create_tables()

        async with db.session() as session:
            dispatcher = NotificationDispatcher(session)
            stats = await dispatcher.process_pending_alerts()

            click.echo(f"\nAlertes trait√©es:")
            click.echo(f"  Total: {stats['total']}")
            click.echo(f"  Envoy√©es: {stats['sent']}")
            click.echo(f"  √âchou√©es: {stats['failed']}")

        await db.close()

    logger.info("Traitement des alertes")
    asyncio.run(run_process())


@alerts.command("check")
def alerts_check() -> None:
    """Ex√©cute les v√©rifications et g√©n√®re de nouvelles alertes."""
    from src.alerting import AlertEngine
    from src.storage import db

    logger = get_logger("cli")

    async def run_check():
        await db.init()
        await db.create_tables()

        async with db.session() as session:
            engine = AlertEngine(session)
            alerts = await engine.run_all_checks()

            click.echo(f"\n{len(alerts)} nouvelles alertes g√©n√©r√©es:")
            for alert in alerts:
                click.echo(f"  [{alert.severite}] {alert.titre}")

        await db.close()

    logger.info("V√©rification des alertes")
    asyncio.run(run_check())


@alerts.command("list")
@click.option("--unread", is_flag=True, help="Uniquement les non lues")
@click.option("--limit", "-n", default=20, help="Nombre d'alertes √† afficher")
def alerts_list(unread: bool, limit: int) -> None:
    """Liste les alertes r√©centes."""
    from sqlalchemy import select
    from src.storage import db
    from src.storage.models import Alert

    async def run_list():
        await db.init()

        async with db.session() as session:
            query = select(Alert).order_by(Alert.created_at.desc()).limit(limit)
            if unread:
                query = query.where(Alert.read_at == None)

            result = await session.execute(query)
            alerts = result.scalars().all()

            if not alerts:
                click.echo("Aucune alerte trouv√©e.")
                return

            click.echo(f"\n{'='*60}")
            click.echo(f"{'ALERTES R√âCENTES':^60}")
            click.echo(f"{'='*60}\n")

            for alert in alerts:
                severity_icon = {"info": "‚ÑπÔ∏è", "attention": "‚ö†Ô∏è", "important": "üî∂", "critique": "üö®"}
                icon = severity_icon.get(alert.severite, "üìå")
                time_str = alert.created_at.strftime("%d/%m %H:%M")
                read_mark = "" if alert.read_at else " *"

                click.echo(f"{icon} [{time_str}] {alert.titre}{read_mark}")
                click.echo(f"   {alert.message[:80]}...")
                click.echo("")

            click.echo(f"Total: {len(alerts)} alertes (* = non lue)")

        await db.close()

    asyncio.run(run_list())


@alerts.command("digest")
@click.option("--period", "-p", type=click.Choice(["daily", "weekly"]), default="daily")
def alerts_digest(period: str) -> None:
    """Envoie un r√©sum√© des alertes."""
    from src.alerting import NotificationDispatcher
    from src.storage import db

    logger = get_logger("cli")

    async def run_digest():
        await db.init()

        async with db.session() as session:
            dispatcher = NotificationDispatcher(session)
            success = await dispatcher.send_digest(period)

            if success:
                click.echo(f"Digest {period} envoy√© avec succ√®s")
            else:
                click.echo("√âchec de l'envoi du digest")

        await db.close()

    logger.info(f"Envoi du digest {period}")
    asyncio.run(run_digest())


@alerts.command("test")
def alerts_test() -> None:
    """Teste les canaux de notification."""
    from src.alerting import NotificationDispatcher
    from src.storage import db

    logger = get_logger("cli")

    async def run_test():
        await db.init()

        async with db.session() as session:
            dispatcher = NotificationDispatcher(session)
            results = await dispatcher.test_channels()

            click.echo("\nTest des canaux de notification:")
            for channel, status in results.items():
                if status is None:
                    click.echo(f"  {channel}: d√©sactiv√©")
                elif status:
                    click.echo(f"  {channel}: ‚úÖ OK")
                else:
                    click.echo(f"  {channel}: ‚ùå √âchec")

        await db.close()

    logger.info("Test des notifications")
    asyncio.run(run_test())


# =========================================================================
# Commandes de rapport
# =========================================================================

@main.group()
def report() -> None:
    """Commandes de g√©n√©ration de rapports."""
    pass


@report.command("weekly")
@click.option("--format", "-f", "output_format",
              type=click.Choice(["html", "pdf", "md", "all"]),
              default="html", help="Format de sortie (html, pdf, md, all)")
def report_weekly(output_format: str) -> None:
    """G√©n√®re le rapport hebdomadaire."""
    from src.reporting import ReportGenerator
    from src.storage import db

    logger = get_logger("cli")

    async def run_report():
        await db.init()
        await db.create_tables()

        async with db.session() as session:
            generator = ReportGenerator(session)

            if output_format == "all":
                formats = ["html", "pdf", "md"]
            else:
                formats = [output_format]

            try:
                report_paths = await generator.generate_weekly_report(formats=formats)
                for path in report_paths:
                    click.echo(f"Rapport g√©n√©r√©: {path}")
            except Exception as e:
                click.echo(f"Erreur g√©n√©ration: {e}")

        await db.close()

    logger.info(f"G√©n√©ration du rapport hebdomadaire ({output_format})")
    asyncio.run(run_report())


@report.command("competitor")
@click.argument("siren")
@click.option("--format", "-f", "output_format",
              type=click.Choice(["html", "pdf"]),
              default="html", help="Format de sortie (html, pdf)")
def report_competitor(siren: str, output_format: str) -> None:
    """G√©n√®re le rapport d'un concurrent par SIREN."""
    from src.reporting import ReportGenerator
    from src.storage import db

    logger = get_logger("cli")

    async def run_report():
        await db.init()
        await db.create_tables()

        async with db.session() as session:
            generator = ReportGenerator(session)

            try:
                report_paths = await generator.generate_competitor_report(
                    siren=siren,
                    formats=[output_format]
                )
                for path in report_paths:
                    click.echo(f"Rapport concurrent g√©n√©r√©: {path}")
            except ValueError as e:
                click.echo(f"Erreur: {e}")
            except Exception as e:
                click.echo(f"Erreur g√©n√©ration: {e}")

        await db.close()

    logger.info(f"G√©n√©ration du rapport concurrent {siren}")
    asyncio.run(run_report())


@report.command("list")
@click.option("--limit", "-n", default=10, help="Nombre de rapports √† afficher")
def report_list(limit: int) -> None:
    """Liste les rapports g√©n√©r√©s."""
    from pathlib import Path

    settings = get_settings()
    reports_dir = settings.get_data_dir() / "exports"

    if not reports_dir.exists():
        click.echo("Aucun rapport g√©n√©r√©.")
        return

    reports = sorted(reports_dir.glob("**/*"), key=lambda p: p.stat().st_mtime, reverse=True)
    reports = [r for r in reports if r.is_file()][:limit]

    if not reports:
        click.echo("Aucun rapport trouv√©.")
        return

    click.echo(f"\n{'='*60}")
    click.echo(f"{'RAPPORTS R√âCENTS':^60}")
    click.echo(f"{'='*60}\n")

    from datetime import datetime

    for report in reports:
        mtime = datetime.fromtimestamp(report.stat().st_mtime)
        size_kb = report.stat().st_size / 1024
        click.echo(f"  {report.name}")
        click.echo(f"    Date: {mtime.strftime('%d/%m/%Y %H:%M')}")
        click.echo(f"    Taille: {size_kb:.1f} KB")
        click.echo(f"    Chemin: {report}")
        click.echo("")


# =========================================================================
# Commandes du scheduler
# =========================================================================

@main.group()
def scheduler() -> None:
    """Commandes du planificateur de t√¢ches."""
    pass


@scheduler.command("start")
def scheduler_start() -> None:
    """D√©marre le scheduler en mode continu."""
    from src.scheduler import run_scheduler

    logger = get_logger("cli")
    logger.info("D√©marrage du scheduler StratWatch")

    click.echo("D√©marrage du scheduler StratWatch...")
    click.echo("Appuyez sur Ctrl+C pour arr√™ter")

    asyncio.run(run_scheduler())


@scheduler.command("jobs")
def scheduler_jobs() -> None:
    """Liste les t√¢ches planifi√©es."""
    from src.scheduler import StratWatchScheduler

    scheduler = StratWatchScheduler()
    scheduler.configure_jobs()

    jobs = scheduler.get_jobs()

    click.echo(f"\n{'='*60}")
    click.echo(f"{'T√ÇCHES PLANIFI√âES':^60}")
    click.echo(f"{'='*60}\n")

    for job in jobs:
        click.echo(f"  {job['name']}")
        click.echo(f"    ID: {job['id']}")
        click.echo(f"    Trigger: {job['trigger']}")
        click.echo(f"    Prochaine ex√©cution: {job['next_run'] or 'N/A'}")
        click.echo("")

    click.echo(f"Total: {len(jobs)} t√¢ches configur√©es")


@scheduler.command("run")
@click.argument("job_id")
def scheduler_run(job_id: str) -> None:
    """Ex√©cute une t√¢che imm√©diatement."""
    from src.scheduler import StratWatchScheduler

    logger = get_logger("cli")

    job_mapping = {
        "collect_legal": "task_collect_legal",
        "collect_bodacc": "task_collect_bodacc",
        "collect_regulations": "task_collect_regulations",
        "check_alerts": "task_check_alerts",
        "send_notifications": "task_send_notifications",
        "daily_digest": "task_send_daily_digest",
        "weekly_digest": "task_send_weekly_digest",
        "weekly_report": "task_generate_weekly_report",
    }

    if job_id not in job_mapping:
        click.echo(f"T√¢che inconnue: {job_id}")
        click.echo(f"T√¢ches disponibles: {', '.join(job_mapping.keys())}")
        return

    scheduler = StratWatchScheduler()
    task_method = getattr(scheduler, job_mapping[job_id])

    logger.info(f"Ex√©cution manuelle: {job_id}")
    click.echo(f"Ex√©cution de la t√¢che: {job_id}...")

    asyncio.run(task_method())
    click.echo("T√¢che termin√©e.")


@scheduler.command("status")
def scheduler_status() -> None:
    """Affiche l'√©tat du scheduler."""
    settings = get_settings()

    click.echo("\n=== √âtat du Scheduler ===\n")

    # Configuration
    reporting = settings.reporting
    click.echo(f"G√©n√©ration auto des rapports: {'Oui' if reporting.auto_generate else 'Non'}")
    click.echo(f"Planning: {reporting.schedule}")
    click.echo(f"Jour de la semaine: {reporting.day_of_week}")
    click.echo(f"Heure: {reporting.hour}:00")
    click.echo("")

    # Intervalles de collecte
    intervals = settings.collection.intervals
    click.echo("Intervalles de collecte:")
    click.echo(f"  - Donn√©es l√©gales: 1x/jour (6h)")
    click.echo(f"  - BODACC: 2x/jour (7h, 19h)")
    click.echo(f"  - R√©glementaire: 2x/jour (8h, 20h)")
    click.echo(f"  - V√©rification alertes: toutes les 30 min")
    click.echo(f"  - Notifications: toutes les 15 min")


if __name__ == "__main__":
    main()
